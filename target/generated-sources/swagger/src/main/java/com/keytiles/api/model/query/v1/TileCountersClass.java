/*
 * Keytiles Statistics query API
 * Provides endpoints to query statistics data stored by Keytiles service    ## Interval of your interest It is common in these queries that you need to define the time interval you are curious about. ### Defining the requested interval You need to define a query interval with timestamps you are curious about. You can:  * go with classic **from-to** fashion - using `fromTimestamp` and `toTimestamp` query parameters together or  * go with **delta approach** - using `fromTimestamp` and `tMinusMinutes` query parameters together    If you do not specify any of the above mentioned parameters then the default mechanism is the is **delta approach**. And query will go with default values of `fromTimestamp` (default: now()) and `tMinusMinutes` (default: Container setting) params.  See parameter descriptions for more details! ### And the returned interval actually ... ... might be different than what you requested. As Keytiles works with 1 minute long time frames in the background - aggregating counters into these time frames. But this resolution of statistics is only kept for a limited time. After that time data is aggregated hourly level. Far more in the past then only daily resolution is available.    It is easier to understand what does it mean exactly for you by taking an example. Let's assume:  * current time is 16:48:22  * and you are requesting `tMinusMinutes = 10` - which means 10 minutes look back  * then basically **you are requesting data for 16:38:22 - 16:48:22** time interval ...  * ... BUT in this case **you will get back data for 16:38:00 - 16:48:22 instead** of your requested interval   This kind of \"rounding\" is happening due to the mechanism Keytiles organizes data behind the scenes. Beginning of your \"fromTimestamp\" is floored down to the closest minute (by removing seconds). ### In the response You will get back this \"rounded\" actual interval the response really has data for in `/dataFromTimestamp` and `/dataToTimestamp` attributes ## Requesting a break down of stats within the interval Let's assume you query the data for the last 12 hours (with `tMinusMinutes = 720`). But you want to see the data not fully aggregated but separately for each hour within the 12 hours interval. Basically you want to see 12 intervals - each having the counters separated.    This is **possible by adding** the `resolution` parameter to your query. However **there are restrictions here...** ### The reason of restrictions Keytiles     1. Keeps **minute based** resolution only for a limited time...  1. Over that time only **hourly based** resolution is available but... it is also just kept until a limited time...  1. Over that time only **daily based** resolution is available.   Keytiles is doing this to keep the data in an efficient form (saving resources) based on the fact that  **it is very very unlikely** that you want to have detailed statistics for 12 minutes of visits from 7 months earlier... ### Therefore... If you query data from a week earlier - as minute based resolution will not be available by that time - if you send in `resolution` **< 1 hour** then your whish of getting this resolution can not be served... :-(    What will happen instead is that you **will get back a \"400 - Bad request\"** error where in the error Keytiles will tell you the problem and also give you a hint about how the request should be modified being able to fulfill that. ### In the reponse You might notice that the response has a section `/resolutionIntervals`.    If you are not requesting this break down then it has only just one element - which is the full interval your data is returned for. But if you have requested this break down then here you will find the interval definitions carrying your break down. The data (counter-set) which is returned deeper in the response will refer to one of these intervals by having attribute called `intervalId` - then you will know to which interval of the requested break down that data belongs to. 
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.keytiles.api.model.query.v1;

import java.util.Objects;
import java.util.Arrays;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

import java.io.Serializable;

public class TileCountersClass implements Serializable{
  private static final long serialVersionUID = 1L;


  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long pageview = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long vsessStarted = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long bounce = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long newVisitor = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long bounceNewVisitor = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long refSearch = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long refInternal = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long refLink = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long refSocial = null;

  // @Generator: listed in 'x-keytiles-serialize-only-if-non-default-properties' - so necessary annotations added here OR to the getter 
  // @Generator: becomes private - as non-nullable so we need to protect it with setter and null-check 
  private Long refDirect = null;


  
  // @Generator: arg 'pageview': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'vsessStarted': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'bounce': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'newVisitor': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'bounceNewVisitor': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'refSearch': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'refInternal': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'refLink': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'refSocial': non-nullable and does not have default value - we must enforce a non-null initial value 
  // @Generator: arg 'refDirect': non-nullable and does not have default value - we must enforce a non-null initial value 
  @JsonCreator
  public TileCountersClass(@JsonProperty("pageview") Long pageview, @JsonProperty("vsessStarted") Long vsessStarted, @JsonProperty("bounce") Long bounce, @JsonProperty("newVisitor") Long newVisitor, @JsonProperty("bounceNewVisitor") Long bounceNewVisitor, @JsonProperty("refSearch") Long refSearch, @JsonProperty("refInternal") Long refInternal, @JsonProperty("refLink") Long refLink, @JsonProperty("refSocial") Long refSocial, @JsonProperty("refDirect") Long refDirect) {
    super();
    if(pageview == null) {
      throw new IllegalArgumentException("'pageview' value can not be NULL");
    }
    if(vsessStarted == null) {
      throw new IllegalArgumentException("'vsessStarted' value can not be NULL");
    }
    if(bounce == null) {
      throw new IllegalArgumentException("'bounce' value can not be NULL");
    }
    if(newVisitor == null) {
      throw new IllegalArgumentException("'newVisitor' value can not be NULL");
    }
    if(bounceNewVisitor == null) {
      throw new IllegalArgumentException("'bounceNewVisitor' value can not be NULL");
    }
    if(refSearch == null) {
      throw new IllegalArgumentException("'refSearch' value can not be NULL");
    }
    if(refInternal == null) {
      throw new IllegalArgumentException("'refInternal' value can not be NULL");
    }
    if(refLink == null) {
      throw new IllegalArgumentException("'refLink' value can not be NULL");
    }
    if(refSocial == null) {
      throw new IllegalArgumentException("'refSocial' value can not be NULL");
    }
    if(refDirect == null) {
      throw new IllegalArgumentException("'refDirect' value can not be NULL");
    }
    this.pageview = pageview;
    this.vsessStarted = vsessStarted;
    this.bounce = bounce;
    this.newVisitor = newVisitor;
    this.bounceNewVisitor = bounceNewVisitor;
    this.refSearch = refSearch;
    this.refInternal = refInternal;
    this.refLink = refLink;
    this.refSocial = refSocial;
    this.refDirect = refDirect;
  }
  
  
 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("pageview")
  public Long getPageview() {
    return pageview;
  }  

  // @Generator: added to protect field 'pageview' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("pageview")
  public void setPageview(Long pageview) {
    if(pageview == null) {
      throw new IllegalArgumentException("'pageview' value can not be NULL");
    }
    this.pageview = pageview;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("vsessStarted")
  public Long getVsessStarted() {
    return vsessStarted;
  }  

  // @Generator: added to protect field 'vsessStarted' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("vsessStarted")
  public void setVsessStarted(Long vsessStarted) {
    if(vsessStarted == null) {
      throw new IllegalArgumentException("'vsessStarted' value can not be NULL");
    }
    this.vsessStarted = vsessStarted;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("bounce")
  public Long getBounce() {
    return bounce;
  }  

  // @Generator: added to protect field 'bounce' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("bounce")
  public void setBounce(Long bounce) {
    if(bounce == null) {
      throw new IllegalArgumentException("'bounce' value can not be NULL");
    }
    this.bounce = bounce;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("newVisitor")
  public Long getNewVisitor() {
    return newVisitor;
  }  

  // @Generator: added to protect field 'newVisitor' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("newVisitor")
  public void setNewVisitor(Long newVisitor) {
    if(newVisitor == null) {
      throw new IllegalArgumentException("'newVisitor' value can not be NULL");
    }
    this.newVisitor = newVisitor;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("bounceNewVisitor")
  public Long getBounceNewVisitor() {
    return bounceNewVisitor;
  }  

  // @Generator: added to protect field 'bounceNewVisitor' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("bounceNewVisitor")
  public void setBounceNewVisitor(Long bounceNewVisitor) {
    if(bounceNewVisitor == null) {
      throw new IllegalArgumentException("'bounceNewVisitor' value can not be NULL");
    }
    this.bounceNewVisitor = bounceNewVisitor;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refSearch")
  public Long getRefSearch() {
    return refSearch;
  }  

  // @Generator: added to protect field 'refSearch' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refSearch")
  public void setRefSearch(Long refSearch) {
    if(refSearch == null) {
      throw new IllegalArgumentException("'refSearch' value can not be NULL");
    }
    this.refSearch = refSearch;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refInternal")
  public Long getRefInternal() {
    return refInternal;
  }  

  // @Generator: added to protect field 'refInternal' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refInternal")
  public void setRefInternal(Long refInternal) {
    if(refInternal == null) {
      throw new IllegalArgumentException("'refInternal' value can not be NULL");
    }
    this.refInternal = refInternal;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refLink")
  public Long getRefLink() {
    return refLink;
  }  

  // @Generator: added to protect field 'refLink' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refLink")
  public void setRefLink(Long refLink) {
    if(refLink == null) {
      throw new IllegalArgumentException("'refLink' value can not be NULL");
    }
    this.refLink = refLink;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refSocial")
  public Long getRefSocial() {
    return refSocial;
  }  

  // @Generator: added to protect field 'refSocial' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refSocial")
  public void setRefSocial(Long refSocial) {
    if(refSocial == null) {
      throw new IllegalArgumentException("'refSocial' value can not be NULL");
    }
    this.refSocial = refSocial;
  }

  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refDirect")
  public Long getRefDirect() {
    return refDirect;
  }  

  // @Generator: added to protect field 'refDirect' against null-value assignment 
  @JsonInclude(Include.NON_DEFAULT)
  @JsonProperty("refDirect")
  public void setRefDirect(Long refDirect) {
    if(refDirect == null) {
      throw new IllegalArgumentException("'refDirect' value can not be NULL");
    }
    this.refDirect = refDirect;
  }



  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TileCountersClass tileCountersClass = (TileCountersClass) o;
    return Objects.equals(this.pageview, tileCountersClass.pageview) &&
        Objects.equals(this.vsessStarted, tileCountersClass.vsessStarted) &&
        Objects.equals(this.bounce, tileCountersClass.bounce) &&
        Objects.equals(this.newVisitor, tileCountersClass.newVisitor) &&
        Objects.equals(this.bounceNewVisitor, tileCountersClass.bounceNewVisitor) &&
        Objects.equals(this.refSearch, tileCountersClass.refSearch) &&
        Objects.equals(this.refInternal, tileCountersClass.refInternal) &&
        Objects.equals(this.refLink, tileCountersClass.refLink) &&
        Objects.equals(this.refSocial, tileCountersClass.refSocial) &&
        Objects.equals(this.refDirect, tileCountersClass.refDirect);
  }

  @Override
  public int hashCode() {
    return Objects.hash(pageview, vsessStarted, bounce, newVisitor, bounceNewVisitor, refSearch, refInternal, refLink, refSocial, refDirect);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TileCountersClass {\n");
    
    sb.append("    pageview: ").append(toIndentedString(pageview)).append("\n");
    sb.append("    vsessStarted: ").append(toIndentedString(vsessStarted)).append("\n");
    sb.append("    bounce: ").append(toIndentedString(bounce)).append("\n");
    sb.append("    newVisitor: ").append(toIndentedString(newVisitor)).append("\n");
    sb.append("    bounceNewVisitor: ").append(toIndentedString(bounceNewVisitor)).append("\n");
    sb.append("    refSearch: ").append(toIndentedString(refSearch)).append("\n");
    sb.append("    refInternal: ").append(toIndentedString(refInternal)).append("\n");
    sb.append("    refLink: ").append(toIndentedString(refLink)).append("\n");
    sb.append("    refSocial: ").append(toIndentedString(refSocial)).append("\n");
    sb.append("    refDirect: ").append(toIndentedString(refDirect)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
