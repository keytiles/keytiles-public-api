/*
 * Keytiles Statistics query API
 *  # Disclaimer **PLEASE NOTE! This is an early release of v2 API which is currently in Beta test phase!**   This means things can still change!   # Overview This API provides endpoints to query statistics data stored by Keytiles service.      To specify / fine tune queries you use query parameters which we can group into a few groups.      ### Query range To make queries you need to specify the query time range. To do that you can use the:   * **fromTimestamp** - Start of your query range inclusive (>=). This is a UNIX timstamp (seconds since Epoch, UTC).    * **toTimestamp** - End of your query range inclusive (<=). This is either a UNIX timestamp or \"now\" as a string meaning current time  ### Filtering Optionally you can filter the data due to several criteria.      For example if you are interested in only \"view\" event types then you can use the **eventTypesOnly=view** filter parameter.   Or you can also filter for **tileIdsOnly=tileId1,tileId2** if you are just interested in specific tiles stat data.      For complete list please check the query parameters of the endpoints! Look for \"***Only**\" parameters! ### Details - your interest By default only the most relevant details are returned however in several endpoints you can definitely ask for more. You can do this using the **interest** query parameter.      For example if you query the event counts for Tiles what you will get back by default is only the total number of events registered in your query range. ### Grouping By default you just get the total event count of all event types captured by Keytiles in the query range. But if you want to compare / see / distinguish this \"total count\" by different view points then you can request Keytiles to \"group the data\" by different things.      For example if you want to see event counts / different tileTypes you can use **groupBy=tileType** query parameter. To see the event count distribution regarding the different eventTypes Keytiles captured you can use **groupBy=eventType**. And you can also combine them like **groupBy=eventType,tileType** to get a full decomposition by these two grouping factors.      Please refer to the \"groupBy\" parameter description to see all possible options! ### Limit / threshold If you have a high traffic website with many many Tiles (content) then you might get back huge data from queries even for a relatively short time range. Experience shows that most of this data might be not important for you in many cases. Therefore you have the possibility to limit Keytiles response size by defining \"send me only the top X\" tiles (as most relevant info) and leave out the rest. Please refer to the \"limit\" and \"threshold\" parameter descriptions for more details on endpoints supporting this! 
 *
 * OpenAPI spec version: 2.4
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.keytiles.api.model.stat.v2;

import java.util.Objects;
import java.util.Arrays;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.keytiles.api.model.stat.v2.IntIdToStrMappingClass;
import com.keytiles.api.model.stat.v2.TimeColumnIntIdToIntervalMappingClass;
import com.keytiles.api.model.stat.v2.TimeIntervalClass;
import java.util.List;
import java.util.Map;

import java.io.Serializable;

public class KeyColumnsIntIdMappingsClass extends TimeColumnIntIdToIntervalMappingClass implements Serializable{
  private static final long serialVersionUID = 1L;



  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("eventType")
  public IntIdToStrMappingClass eventType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("visitorType")
  public IntIdToStrMappingClass visitorType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("userAgentType")
  public IntIdToStrMappingClass userAgentType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("tileLanguage")
  public IntIdToStrMappingClass tileLanguage = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("tileType")
  public IntIdToStrMappingClass tileType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("tileGroupPath")
  public IntIdToStrMappingClass tileGroupPath = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("eventSourceType")
  public IntIdToStrMappingClass eventSourceType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("eventSourceName")
  public IntIdToStrMappingClass eventSourceName = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("visitSourceType")
  public IntIdToStrMappingClass visitSourceType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("visitSourceName")
  public IntIdToStrMappingClass visitSourceName = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("trafficSourceType")
  public IntIdToStrMappingClass trafficSourceType = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("trafficSourceName")
  public IntIdToStrMappingClass trafficSourceName = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("campaign")
  public IntIdToStrMappingClass campaign = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("campaignMedium")
  public IntIdToStrMappingClass campaignMedium = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("campaignContent")
  public IntIdToStrMappingClass campaignContent = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("primaryTags")
  public IntIdToStrMappingClass primaryTags = null;

  // @Generator: field refers to 'IntIdToStrMappingClass' which is 'nullable=true' so this is inherited into this field 
  // @Generator: becomes public - as nullable (no need to null-check) and not readonly 
  @JsonProperty("secondaryTags")
  public IntIdToStrMappingClass secondaryTags = null;

  
  
  
 


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KeyColumnsIntIdMappingsClass keyColumnsIntIdMappingsClass = (KeyColumnsIntIdMappingsClass) o;
    return Objects.equals(this.eventType, keyColumnsIntIdMappingsClass.eventType) &&
        Objects.equals(this.visitorType, keyColumnsIntIdMappingsClass.visitorType) &&
        Objects.equals(this.userAgentType, keyColumnsIntIdMappingsClass.userAgentType) &&
        Objects.equals(this.tileLanguage, keyColumnsIntIdMappingsClass.tileLanguage) &&
        Objects.equals(this.tileType, keyColumnsIntIdMappingsClass.tileType) &&
        Objects.equals(this.tileGroupPath, keyColumnsIntIdMappingsClass.tileGroupPath) &&
        Objects.equals(this.eventSourceType, keyColumnsIntIdMappingsClass.eventSourceType) &&
        Objects.equals(this.eventSourceName, keyColumnsIntIdMappingsClass.eventSourceName) &&
        Objects.equals(this.visitSourceType, keyColumnsIntIdMappingsClass.visitSourceType) &&
        Objects.equals(this.visitSourceName, keyColumnsIntIdMappingsClass.visitSourceName) &&
        Objects.equals(this.trafficSourceType, keyColumnsIntIdMappingsClass.trafficSourceType) &&
        Objects.equals(this.trafficSourceName, keyColumnsIntIdMappingsClass.trafficSourceName) &&
        Objects.equals(this.campaign, keyColumnsIntIdMappingsClass.campaign) &&
        Objects.equals(this.campaignMedium, keyColumnsIntIdMappingsClass.campaignMedium) &&
        Objects.equals(this.campaignContent, keyColumnsIntIdMappingsClass.campaignContent) &&
        Objects.equals(this.primaryTags, keyColumnsIntIdMappingsClass.primaryTags) &&
        Objects.equals(this.secondaryTags, keyColumnsIntIdMappingsClass.secondaryTags) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(eventType, visitorType, userAgentType, tileLanguage, tileType, tileGroupPath, eventSourceType, eventSourceName, visitSourceType, visitSourceName, trafficSourceType, trafficSourceName, campaign, campaignMedium, campaignContent, primaryTags, secondaryTags, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeyColumnsIntIdMappingsClass {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    eventType: ").append(toIndentedString(eventType)).append("\n");
    sb.append("    visitorType: ").append(toIndentedString(visitorType)).append("\n");
    sb.append("    userAgentType: ").append(toIndentedString(userAgentType)).append("\n");
    sb.append("    tileLanguage: ").append(toIndentedString(tileLanguage)).append("\n");
    sb.append("    tileType: ").append(toIndentedString(tileType)).append("\n");
    sb.append("    tileGroupPath: ").append(toIndentedString(tileGroupPath)).append("\n");
    sb.append("    eventSourceType: ").append(toIndentedString(eventSourceType)).append("\n");
    sb.append("    eventSourceName: ").append(toIndentedString(eventSourceName)).append("\n");
    sb.append("    visitSourceType: ").append(toIndentedString(visitSourceType)).append("\n");
    sb.append("    visitSourceName: ").append(toIndentedString(visitSourceName)).append("\n");
    sb.append("    trafficSourceType: ").append(toIndentedString(trafficSourceType)).append("\n");
    sb.append("    trafficSourceName: ").append(toIndentedString(trafficSourceName)).append("\n");
    sb.append("    campaign: ").append(toIndentedString(campaign)).append("\n");
    sb.append("    campaignMedium: ").append(toIndentedString(campaignMedium)).append("\n");
    sb.append("    campaignContent: ").append(toIndentedString(campaignContent)).append("\n");
    sb.append("    primaryTags: ").append(toIndentedString(primaryTags)).append("\n");
    sb.append("    secondaryTags: ").append(toIndentedString(secondaryTags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
