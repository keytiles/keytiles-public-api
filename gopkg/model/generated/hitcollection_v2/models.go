// Package kt_pubapi_gen_hitcollectionv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package kt_pubapi_gen_hitcollectionv2

import (
	externalRef0 "github.com/keytiles/keytiles-public-api/v2/gopkg/model/generated/common/types_v3"
)

// Defines values for HitClassMethod.
const (
	HitClassMethodAbsolute    HitClassMethod = "absolute"
	HitClassMethodIncremental HitClassMethod = "incremental"
)

// Defines values for HitCollectionEndpointErrorCodes.
const (
	HitCollectionEndpointErrorCodesActionTokenInternalError         HitCollectionEndpointErrorCodes = "actionToken_internalError"
	HitCollectionEndpointErrorCodesActionTokenInvalid               HitCollectionEndpointErrorCodes = "actionToken_invalid"
	HitCollectionEndpointErrorCodesActionTokenMissing               HitCollectionEndpointErrorCodes = "actionToken_missing"
	HitCollectionEndpointErrorCodesActionTokenUnknownType           HitCollectionEndpointErrorCodes = "actionToken_unknownType"
	HitCollectionEndpointErrorCodesAuthenticationBase64DecodeFailed HitCollectionEndpointErrorCodes = "authentication_base64DecodeFailed"
	HitCollectionEndpointErrorCodesAuthenticationInternalError      HitCollectionEndpointErrorCodes = "authentication_internalError"
	HitCollectionEndpointErrorCodesAuthenticationInvalidCredentials HitCollectionEndpointErrorCodes = "authentication_invalid_credentials"
	HitCollectionEndpointErrorCodesAuthenticationMethodNotSupported HitCollectionEndpointErrorCodes = "authentication_methodNotSupported"
	HitCollectionEndpointErrorCodesAuthenticationMissing            HitCollectionEndpointErrorCodes = "authentication_missing"
	HitCollectionEndpointErrorCodesAuthenticationUserDisabled       HitCollectionEndpointErrorCodes = "authentication_userDisabled"
	HitCollectionEndpointErrorCodesAuthorizationNoPermission        HitCollectionEndpointErrorCodes = "authorization_noPermission"
	HitCollectionEndpointErrorCodesContainerIdInvalid               HitCollectionEndpointErrorCodes = "containerId_invalid"
	HitCollectionEndpointErrorCodesEventDataInvalid                 HitCollectionEndpointErrorCodes = "eventData_invalid"
	HitCollectionEndpointErrorCodesEventDataJsonDecodeFailed        HitCollectionEndpointErrorCodes = "eventData_jsonDecodeFailed"
	HitCollectionEndpointErrorCodesEventDataMissing                 HitCollectionEndpointErrorCodes = "eventData_missing"
	HitCollectionEndpointErrorCodesEventTimeInFuture                HitCollectionEndpointErrorCodes = "eventTime_in_future"
	HitCollectionEndpointErrorCodesFieldDeprecated                  HitCollectionEndpointErrorCodes = "field_deprecated"
	HitCollectionEndpointErrorCodesMandatoryEmailSendingFailed      HitCollectionEndpointErrorCodes = "mandatoryEmailSending_failed"
	HitCollectionEndpointErrorCodesQueryLimitReached                HitCollectionEndpointErrorCodes = "query_limit_reached"
	HitCollectionEndpointErrorCodesRequestDataContradicting         HitCollectionEndpointErrorCodes = "requestData_contradicting"
	HitCollectionEndpointErrorCodesRequestDataInvalid               HitCollectionEndpointErrorCodes = "requestData_invalid"
	HitCollectionEndpointErrorCodesRequestDataMissing               HitCollectionEndpointErrorCodes = "requestData_missing"
	HitCollectionEndpointErrorCodesRequestDataNotSupported          HitCollectionEndpointErrorCodes = "requestData_not_supported"
	HitCollectionEndpointErrorCodesRequestDataWrongFormat           HitCollectionEndpointErrorCodes = "requestData_wrongFormat"
	HitCollectionEndpointErrorCodesRequestParameterConflict         HitCollectionEndpointErrorCodes = "requestParameter_conflict"
	HitCollectionEndpointErrorCodesRequestParameterContradicting    HitCollectionEndpointErrorCodes = "requestParameter_contradicting"
	HitCollectionEndpointErrorCodesRequestParameterInvalid          HitCollectionEndpointErrorCodes = "requestParameter_invalid"
	HitCollectionEndpointErrorCodesRequestParameterMissing          HitCollectionEndpointErrorCodes = "requestParameter_missing"
	HitCollectionEndpointErrorCodesRequestParameterNotSupported     HitCollectionEndpointErrorCodes = "requestParameter_not_supported"
	HitCollectionEndpointErrorCodesRequestParameterPointless        HitCollectionEndpointErrorCodes = "requestParameter_pointless"
	HitCollectionEndpointErrorCodesRequestParameterWrongFormat      HitCollectionEndpointErrorCodes = "requestParameter_wrongFormat"
	HitCollectionEndpointErrorCodesResourceDataConflict             HitCollectionEndpointErrorCodes = "resourceData_conflict"
	HitCollectionEndpointErrorCodesResourceDataContradicting        HitCollectionEndpointErrorCodes = "resourceData_contradicting"
	HitCollectionEndpointErrorCodesResourceDataInvalid              HitCollectionEndpointErrorCodes = "resourceData_invalid"
	HitCollectionEndpointErrorCodesResourceDataMissing              HitCollectionEndpointErrorCodes = "resourceData_missing"
	HitCollectionEndpointErrorCodesResourceDataNotSupported         HitCollectionEndpointErrorCodes = "resourceData_not_supported"
	HitCollectionEndpointErrorCodesResourceDataPointless            HitCollectionEndpointErrorCodes = "resourceData_pointless"
	HitCollectionEndpointErrorCodesResourceDataWrongFormat          HitCollectionEndpointErrorCodes = "resourceData_wrongFormat"
	HitCollectionEndpointErrorCodesResourceVersionMismatch          HitCollectionEndpointErrorCodes = "resourceVersion_mismatch"
	HitCollectionEndpointErrorCodesTileIdEnrichmentFailed           HitCollectionEndpointErrorCodes = "tileId_enrichment_failed"
	HitCollectionEndpointErrorCodesUnderlyingResourceUnavailable    HitCollectionEndpointErrorCodes = "underlying_resource_unavailable"
	HitCollectionEndpointErrorCodesUrlInvalid                       HitCollectionEndpointErrorCodes = "url_invalid"
)

// Defines values for HitCollectionEndpointLocalErrorCodes.
const (
	HitCollectionEndpointLocalErrorCodesContainerIdInvalid        HitCollectionEndpointLocalErrorCodes = "containerId_invalid"
	HitCollectionEndpointLocalErrorCodesEventDataInvalid          HitCollectionEndpointLocalErrorCodes = "eventData_invalid"
	HitCollectionEndpointLocalErrorCodesEventDataJsonDecodeFailed HitCollectionEndpointLocalErrorCodes = "eventData_jsonDecodeFailed"
	HitCollectionEndpointLocalErrorCodesEventDataMissing          HitCollectionEndpointLocalErrorCodes = "eventData_missing"
	HitCollectionEndpointLocalErrorCodesEventTimeInFuture         HitCollectionEndpointLocalErrorCodes = "eventTime_in_future"
	HitCollectionEndpointLocalErrorCodesTileIdEnrichmentFailed    HitCollectionEndpointLocalErrorCodes = "tileId_enrichment_failed"
)

// Defines values for WebhitClassMethod.
const (
	WebhitClassMethodAbsolute    WebhitClassMethod = "absolute"
	WebhitClassMethodIncremental WebhitClassMethod = "incremental"
)

// CampaignData If this hit was generated from a visit arrived from a Campaign this object contains the data of that Campaign.
//
// Please note that this is designed around [UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters) for now so parts of this data are definitely correlating.
//
// Please also note that if you do not send this data but 'tileUrl' contains the above UTM parameters then Keytiles will detect those automatically and recognize the Campaign. You can read more about this in our [How does Campaign tracking work](https://www.keytiles.com/docs/how-does-campaign-tracking-work) article.
type CampaignData struct {
	// Content Identifies what specifically was clicked to bring the user to the site, such as a banner ad or a text link. It is often used for A/B testing and content-targeted ads.
	Content *string `json:"content" yaml:"content"`

	// Medium Identifies what type of link was used, such as Pay-per-click or email.
	Medium *string `json:"medium" yaml:"medium"`

	// Name Identifies a specific product promotion or strategic campaign.
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// HitClass defines model for HitClass.
type HitClass struct {
	// ClientTimeMillis The client clock (time) of the event with millis precision as UNIX timestamp in UTC (millis since Epoch).
	//
	// If you are sending event real time just put in the client clock value! But if you are sending back dated events (see 'eventTimeMillis' field!) then make sure this timestamp is equal to the time of the event!
	//
	// We recommend to send this timestamp as this helps Keytiles to recognize order of sent in events correctly - no matter how big the latency is between the client and Keytiles servers.
	//
	// This field does not behave or substitute 'eventTimeMillis' field at all!
	ClientTimeMillis *int64 `json:"clientTimeMillis" yaml:"clientTimeMillis"`

	// ContainerId Mandatory field. This identifies the Container of the tracking data where this hit belongs to.
	ContainerId string `json:"containerId" yaml:"containerId"`

	// EventTimeMillis The time of the event with millis precision as UNIX timestamp in UTC (millis since Epoch).
	//
	// This is not a mandatory field - if you leave it out (or leave on 'null') Keytiles will automatically use the server side 'now()' timestamp.
	//
	// Although this is possible to send in events with back dated timestamps (sending in older / missed events - which would then retrospectively change data) we strongly recommend to leave this field out (or 'null') and let Keytiles servers use 'now()' timestamp if you are sending events real time!
	//
	// Value can not point into the future (due to server time!). If this happens then it is corrected on server side to 'now()' and raising a warning. Please note you can query the server time if you want to calculate local-remote clock diff - see QueryAPI!
	EventTimeMillis *int64 `json:"eventTimeMillis" yaml:"eventTimeMillis"`

	// HitProducer Optional field. Identifies the hit sender agent.
	//
	// For example in the webhits business domain if the hit was generated by our tracking JavaScript then it is "ktTrackingJs"
	HitProducer *string `json:"hitProducer" yaml:"hitProducer"`

	// Method Describes how the value is used. **incremental:** means the value is added to the stored values. **absolute:** means the value is overriding the current stored value.
	Method HitClassMethod `json:"method" yaml:"method"`

	// SourceTime For backward compatibility only - please use 'eventTimeMillis' instead!
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	SourceTime *int32 `json:"sourceTime" yaml:"sourceTime"`

	// TileGroupPath Optional field but it is strongly recommended to send this... Similar to folder paths - describes the content structure the Tile belongs to.
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileGroupPath-attribute)
	TileGroupPath *string `json:"tileGroupPath" yaml:"tileGroupPath"`

	// TileId Mandatory field. The unique identifier of the Tile which is getting the hit.
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileId-attribute)
	TileId string `json:"tileId" yaml:"tileId"`

	// TileLabelsJSON Optional field. You have the possibility to store a limited amount of labels - key-value pairs - with Tiles in Keytiles. You get them back via the query result if you do so.
	//
	// The Value must be a valid JSON encoding an Object. Please note that the maximum size of this string is also limited! If you violate any of these then this attribute will be simply skipped and already persisted labels will remain unchanged.
	//
	// For more information you should check [https://www.keytiles.com/developer-area/hit-attributes](https://www.keytiles.com/developer-area/hit-attributes#tileLabelsJSON)
	TileLabelsJSON *string `json:"tileLabelsJSON" yaml:"tileLabelsJSON"`

	// TileTitle Mandatory field. This title will be displayed on the Tile in the Keytiles UI.
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileTitle-attribute)
	TileTitle string `json:"tileTitle" yaml:"tileTitle"`
	Value     int    `json:"value" yaml:"value"`
}

// HitClassMethod Describes how the value is used. **incremental:** means the value is added to the stored values. **absolute:** means the value is overriding the current stored value.
type HitClassMethod string

// HitCollectionEndpointErrorCodes defines model for HitCollectionEndpointErrorCodes.
type HitCollectionEndpointErrorCodes string

// HitCollectionEndpointLocalErrorCodes defines model for HitCollectionEndpointLocalErrorCodes.
type HitCollectionEndpointLocalErrorCodes string

// VisitorEnvironment Contains information about the client machine. Everything is optional here - even this object itself.
type VisitorEnvironment struct {
	// Locale The localce data of the visitor's device or user agent.
	Locale *string `json:"locale" yaml:"locale"`

	// OpSystem The name (and version) of the Operating System the visitor's web client is running on
	//
	// **IMPORTANT NOTE:** This is a sensitive field! Keytiles might store this value so make sure you never use accidentaly any data in this field which is personal or sensitive data of your visitor
	OpSystem *string `json:"opSystem" yaml:"opSystem"`

	// Resolution Screen resolution of the client in format "<width> x <height>" - in pixels
	Resolution *string `json:"resolution" yaml:"resolution"`

	// WebClient The name (and version) of the web client the visitor is using to visit the page.
	//
	// If *userAgentType* value is "browser-desktop" or "browser-mobile" then the navigator.userAgent string - provided by the Web Browser - might come in here
	//
	// **IMPORTANT NOTE:** This is a sensitive field! Keytiles might store this value so make sure you never use accidentaly any data in this field which is personal or sensitive data of your visitor
	WebClient *string `json:"webClient" yaml:"webClient"`

	// WindowId Unique ID of the content window. (E.g. in WebBrowser world these are browser tabs/windows). A randomly generated short ID is perfectly enough for this.
	//
	// Keytiles can track visitor activity / content window correctly and separated - if this identifier is porvided. This takes part e.g. in building the "fromTile -> toTile" visitor flow better and in some other cases.
	//
	// If you can produce this value easily then we recommend to send this data. But if not, and you still want to have correct "fromTile -> toTile" flow tracking then please consider sending *referrerTileId* (preferably) or *referrerUrl*!
	WindowId *string `json:"windowId" yaml:"windowId"`

	// WindowSize Size of the web client window in format "<width> x <height>" - in pixels
	WindowSize *string `json:"windowSize" yaml:"windowSize"`
}

// WebhitClass defines model for WebhitClass.
type WebhitClass struct {
	// Action Same as 'eventType' - earlier versions took that info in this parameter but this is deprecated by now - DO NOT USE IT!
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Action *string `json:"action,omitempty" yaml:"action,omitempty"`

	// CampaignData If this hit was generated from a visit arrived from a Campaign this object contains the data of that Campaign.
	//
	// Please note that this is designed around [UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters) for now so parts of this data are definitely correlating.
	//
	// Please also note that if you do not send this data but 'tileUrl' contains the above UTM parameters then Keytiles will detect those automatically and recognize the Campaign. You can read more about this in our [How does Campaign tracking work](https://www.keytiles.com/docs/how-does-campaign-tracking-work) article.
	CampaignData *CampaignData `json:"campaignData" yaml:"campaignData"`

	// ClientTimeMillis The client clock (time) of the event with millis precision as UNIX timestamp in UTC (millis since Epoch).
	//
	// If you are sending event real time just put in the client clock value! But if you are sending back dated events (see 'eventTimeMillis' field!) then make sure this timestamp is equal to the time of the event!
	//
	// We recommend to send this timestamp as this helps Keytiles to recognize order of sent in events correctly - no matter how big the latency is between the client and Keytiles servers.
	//
	// This field does not behave or substitute 'eventTimeMillis' field at all!
	ClientTimeMillis *int64 `json:"clientTimeMillis" yaml:"clientTimeMillis"`

	// ContainerId Mandatory field. This identifies the Container of the tracking data where this hit belongs to.
	ContainerId string `json:"containerId" yaml:"containerId"`

	// EventParams This is a string representation of a JSON object which carries parameters related to how the 'eventType' is processed.  Due to its nature the content of this key-value pairs might be specific to the 'eventType'. But it also has generic entries.
	//
	// Generic entries: * **skipUniqueFilter** - boolean
	//   Optional parameter. By default it is "false" as Keytiles by default measures incoming events belong to the same tileId just once
	//   per VisitSession (forming up the term e.g. "unique pageview"). But if you set this to "true" then Keytiles will not make
	//   the event "unique" in the VisitSession but if it occurs 5 times then will be measured 5 times.
	EventParams *string `json:"eventParams" yaml:"eventParams"`

	// EventTimeMillis The time of the event with millis precision as UNIX timestamp in UTC (millis since Epoch).
	//
	// This is not a mandatory field - if you leave it out (or leave on 'null') Keytiles will automatically use the server side 'now()' timestamp.
	//
	// Although this is possible to send in events with back dated timestamps (sending in older / missed events - which would then retrospectively change data) we strongly recommend to leave this field out (or 'null') and let Keytiles servers use 'now()' timestamp if you are sending events real time!
	//
	// Value can not point into the future (due to server time!). If this happens then it is corrected on server side to 'now()' and raising a warning. Please note you can query the server time if you want to calculate local-remote clock diff - see QueryAPI!
	EventTimeMillis *int64 `json:"eventTimeMillis" yaml:"eventTimeMillis"`

	// EventType Mandatory field. Defines what has happened (so eventually which counter to increase)
	//
	// There are several pre-defined eventTypes, namely * pageview (default, by our tracking script) * view * download * upload * login * logout * submitted (e.g. a form) * ping * scrolledTo
	// but you can send in even totally **custom strings as eventTypes**! Keytiles will track them correctly.
	//
	// If you do not send in eventType then it's a problem... In this case an error level Hit Fault is generated and the hit is skipped.   note: Check our article about [Hit faults](https://www.keytiles.com/developer-area/checking-and-troubleshooting/hit-faults) to get a better understanding!
	EventType string `json:"eventType" yaml:"eventType"`

	// HitProducer Optional field. Identifies the hit sender agent.
	//
	// For example in the webhits business domain if the hit was generated by our tracking JavaScript then it is "ktTrackingJs"
	HitProducer *string `json:"hitProducer" yaml:"hitProducer"`

	// Method Describes how the value is used. **incremental:** means the value is added to the stored values. **absolute:** means the value is overriding the current stored value.
	Method WebhitClassMethod `json:"method" yaml:"method"`

	// PrimaryTags Optional field. A comma separated list of custom tags you would like to tag the Event with - carried by this hit.
	//
	// The tags are simple strings - name them as you want/need.
	//
	// Once you tag the Event with these tags then you have the possibility in query time of course to query only the appropriate segment of your traffic matching the tags you want to see.
	//
	// To understand it better what these "tags" are doing and how you can use it for your own goals please check our article: [Custom segmentation of traffic](https://keytiles.com/developer-area/custom-segmentation-of-traffic)!
	//
	// Please note the following: * You can use maximum 3 different tags (comma separated) here in the list. This is an intentional limitation on our end for now.
	//   This means you can send in something like "blue,green" that's OK but you can not send in "green,blue,red,yellow" - it is exceeding the simultaneous limit.
	//   If you violate this then the overflowing tags will be simple omitted and a warning level Hit Fault is generated.
	//   note: Check our article about [Hit faults](https://www.keytiles.com/developer-area/checking-and-troubleshooting/hit-faults) to get a better understanding!
	// * The length of one tag can be maximum 24 characters.
	//   So "green" fits as a tag easily. But "my-long-color-name-description" (30 long) does not! If you violate this then the tag will be simple omitted and a warning level Hit Fault is generated.
	//   note: Check our article about [Hit faults](https://www.keytiles.com/developer-area/checking-and-troubleshooting/hit-faults) to get a better understanding!
	PrimaryTags *string `json:"primaryTags" yaml:"primaryTags"`

	// PseudoUniqueWebClientId Optional field. Similar to *uniqueWebClientId* with one difference: with this field you basically say that you have an ID which is "very likely" unique but you can not guarantee this (for whatever reason).
	//
	// This might come into the picture if e.g. the user has disabled cookies in his/her web browser so we can not generate a "for sure" *uniqueWebClientId*. Rather than that we still might be able to generate kind of a "fingerprint" of his/her browser by taking into account some - very likely unique - values of his device.
	//
	// **IMPORTANT NOTE:** This is a sensitive field! Keytiles might store this value so never use any data in this field which is personal or sensitive data of your visitor - even if you know it and using that would be the easiest solution for you!
	PseudoUniqueWebClientId *string `json:"pseudoUniqueWebClientId" yaml:"pseudoUniqueWebClientId"`

	// ReferrerTileId Optional field. The value tells Keytiles from which Tile the visitor came from.
	//
	// This makes sense only if the referrer is internal of course. And this one is really playing a role in building up the visitor flow internally on the tracked website.
	//
	// If this value is provided then it takes precedence over the value in the *referrerUrl* field very likely.
	ReferrerTileId *string `json:"referrerTileId" yaml:"referrerTileId"`

	// ReferrerUrl Optional field. The value tells Keytiles from where the visitor - which URL - came from.
	//
	// This is playing role in being able to track external/internal referrers and visitor flow so if you have this information you should send it.
	ReferrerUrl *string `json:"referrerUrl" yaml:"referrerUrl"`

	// SecondaryTags Optional field. A comma separated list of custom tags you would like to tag the Event with - carried by this hit.
	//
	// Technically it works the same way as `primaryTags` - please check that! - but this "secondary" tags can represent something else as categorization compared to the primary tags.
	//
	// To understand it better what these "tags" are doing and how you can use it for your own goals please check our article: [Custom segmentation of traffic](https://keytiles.com/developer-area/custom-segmentation-of-traffic)!
	SecondaryTags *string `json:"secondaryTags" yaml:"secondaryTags"`

	// SourceTime For backward compatibility only - please use 'eventTimeMillis' instead!
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	SourceTime *int32 `json:"sourceTime" yaml:"sourceTime"`

	// TileGroupPath Optional field but it is strongly recommended to send this... Similar to folder paths - describes the content structure the Tile belongs to.
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileGroupPath-attribute)
	TileGroupPath *string `json:"tileGroupPath" yaml:"tileGroupPath"`

	// TileId Mandatory field. The unique identifier of the Tile which is getting the hit.
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileId-attribute)
	TileId string `json:"tileId" yaml:"tileId"`

	// TileLabelsJSON Optional field. You have the possibility to store a limited amount of labels - key-value pairs - with Tiles in Keytiles. You get them back via the query result if you do so.
	//
	// The Value must be a valid JSON encoding an Object. Please note that the maximum size of this string is also limited! If you violate any of these then this attribute will be simply skipped and already persisted labels will remain unchanged.
	//
	// For more information you should check [https://www.keytiles.com/developer-area/hit-attributes](https://www.keytiles.com/developer-area/hit-attributes#tileLabelsJSON)
	TileLabelsJSON *string `json:"tileLabelsJSON" yaml:"tileLabelsJSON"`

	// TileLanguage Optional field. You can send in an ISO-639-1 two letters language code e.g. 'en'.
	//
	// This would let Keytiles know in which language your visitor has viewed the tile.
	TileLanguage *string `json:"tileLanguage" yaml:"tileLanguage"`

	// TileTitle Mandatory field. This title will be displayed on the Tile in the Keytiles UI.
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileTitle-attribute)
	TileTitle string `json:"tileTitle" yaml:"tileTitle"`

	// TileType Mandatory field. The type of the content (Tile).
	//
	// There are several pre-defined types which you might consider to use if they fit to your use case however **you can also define your own types** too. By convention you should not put spaces or weird characters into this string (however technically it is not causing any issues)
	//
	// The predefined types are: * frontpage * page * article * file * form * questionnaire * post * comment * profile * photo * video * gallery
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileType-attribute)
	//
	// In case you do not send in any values here then it is automatically defaulted to 'article' type and a warning level Hit Fault is generated.   note: Check our article about [Hit faults](https://www.keytiles.com/developer-area/checking-and-troubleshooting/hit-faults) to get a better understanding!
	TileType *string `json:"tileType" yaml:"tileType"`

	// TileUrl URLs are just meta-data for your Tiles. (As we do know well that even the very same article can appear under many different concrete URLs) A Tile can have multiple URLs however try to reduce it if possible...
	//
	// To understand better what this field is you should check [https://keytiles.com/developer-area/hit-attributes](https://keytiles.com/developer-area/hit-attributes#tileUrl-attribute)
	TileUrl *string `json:"tileUrl" yaml:"tileUrl"`

	// UniqueWebClientId Optional field however using this is strongly recommended - if possible! This is a unique identifier of the visitor's user agent: meaning his web browser or mobile device.
	//
	// This value is the soul of the so called "visit session" term and might heavily affect the "bouncer" values.
	//
	// **IMPORTANT NOTE:** This is a sensitive field! Keytiles will store this value so never use any data in this field which is personal or sensitive data of your visitor - even if you know it and using that would be the easiest solution for you!
	//
	// Just to give you a quick idea: when the hit is collected by our tracking JavaScript then this ID is just a UUID style randomly generated thing - stored in Cookie under the user's web browser for future actions. And yes, even if the visitor person is the same if he is using multiple devices this ID should and must be unique / device (aka Web Client App)
	//
	// In case you can not provide this value for whatever reason please see also *pseudoUniqueWebClientId* field!
	UniqueWebClientId *string `json:"uniqueWebClientId" yaml:"uniqueWebClientId"`

	// UserAgentType Mandatory field. Tells Keytiles the type of the web client the visitor is using.
	//
	// This is an important information as traffic is segregated by this value. There are a few "built in" values:
	//  * **browser-desktop** - means this is a web browser, desktop computer version
	//  * **browser-mobile** - means this is a web browser, mobile device version like smart phone or tablet
	//
	// But you can also define and send in custom values (in case you have custom web clients like a native iOS / Android readers or Apps and you want to track the traffic generated through them) too!
	//
	// In this case you just simple give them meaningful names you will recognize on your own side. E.g. "Android App" or similar.
	//
	// If you do not send in any values here then Keytiles automatically maps "unknown" as value and a warning level Hit Fault is created.
	//
	// note: Check our article about [Hit faults](https://www.keytiles.com/developer-area/checking-and-troubleshooting/hit-faults) to get a better understanding!
	UserAgentType string `json:"userAgentType" yaml:"userAgentType"`
	Value         int    `json:"value" yaml:"value"`

	// VisitorEnvironment Contains information about the client machine. Everything is optional here - even this object itself.
	VisitorEnvironment *VisitorEnvironment `json:"visitorEnvironment" yaml:"visitorEnvironment"`

	// VisitorType Optional. If you want to distinguish let's say "free" visitors generated traffic from "paid" visitors then this is the place you can do this by providing visitor type. It's up to you how you want to call and how many different visitor types you want to distinguish.
	VisitorType *string `json:"visitorType" yaml:"visitorType"`
}

// WebhitClassMethod Describes how the value is used. **incremental:** means the value is added to the stored values. **absolute:** means the value is overriding the current stored value.
type WebhitClassMethod string

// WebhitsResponseClass defines model for WebhitsResponseClass.
type WebhitsResponseClass struct {
	DebugInfo *struct {
		// TileIdGenerator If tileId was generated then tells which mechanism has generated it.
		TileIdGenerator *string `json:"tileIdGenerator" yaml:"tileIdGenerator"`
	} `json:"debugInfo,omitempty" yaml:"debugInfo,omitempty"`

	// Message The human readable message
	Message *string `json:"message,omitempty" yaml:"message,omitempty"`

	// Problems List of errors/warnings
	Problems *[]externalRef0.ProblemV3Class `json:"problems" yaml:"problems"`

	// ProcessingTookMillis Number of milliseconds the processing took on server side
	ProcessingTookMillis *int32 `json:"processingTookMillis" yaml:"processingTookMillis"`

	// RequestReceivedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
	RequestReceivedAt int32 `json:"requestReceivedAt" yaml:"requestReceivedAt"`

	// TileId Gives you the ID of the Tile which will be used for processing this hit.
	//
	// If there was incoming 'hit.tileId' in the request then this will be simply that. But if there was not then this is the tileId Keytiles has generated from the hit attributes.
	TileId *string `json:"tileId,omitempty" yaml:"tileId,omitempty"`

	// Vars Extra data (variables) the endpoint wants to return for programmatic processing.
	Vars *map[string]interface{} `json:"vars" yaml:"vars"`
}

// PostV1WebhitsJSONRequestBody defines body for PostV1Webhits for application/json ContentType.
type PostV1WebhitsJSONRequestBody = WebhitClass
