// Package kt_pubapi_gen_reportsv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package kt_pubapi_gen_reportsv1

import (
	"encoding/json"
	"fmt"

	externalRef0 "github.com/keytiles/keytiles-public-api/v2/gopkg/model/generated/common/metadata_v1"
	externalRef1 "github.com/keytiles/keytiles-public-api/v2/gopkg/model/generated/common/schedule_v1"
	externalRef2 "github.com/keytiles/keytiles-public-api/v2/gopkg/model/generated/common/types_v3"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for ReportInstanceSectionState.
const (
	ReportInstanceSectionStateComplete   ReportInstanceSectionState = "complete"
	ReportInstanceSectionStateCreated    ReportInstanceSectionState = "created"
	ReportInstanceSectionStateGenerating ReportInstanceSectionState = "generating"
)

// Defines values for ReportInstanceState.
const (
	ReportInstanceStateComplete   ReportInstanceState = "complete"
	ReportInstanceStateCreated    ReportInstanceState = "created"
	ReportInstanceStateGenerating ReportInstanceState = "generating"
)

// Defines values for ReportQueryPlugin.
const (
	CampaignPerformancePlugin ReportQueryPlugin = "campaignPerformancePlugin"
	EventCountPlugin          ReportQueryPlugin = "eventCountPlugin"
	LinksPerformancePlugin    ReportQueryPlugin = "linksPerformancePlugin"
	SocialPerformancePlugin   ReportQueryPlugin = "socialPerformancePlugin"
	TagsPerformancePlugin     ReportQueryPlugin = "tagsPerformancePlugin"
	VisitorBehaviorPlugin     ReportQueryPlugin = "visitorBehaviorPlugin"
)

// Defines values for ReportRecipientsRoles.
const (
	Admin     ReportRecipientsRoles = "admin"
	Developer ReportRecipientsRoles = "developer"
	View      ReportRecipientsRoles = "view"
)

// Defines values for ReportsEndpointErrorCodes.
const (
	ReportsEndpointErrorCodesActionTokenInternalError         ReportsEndpointErrorCodes = "actionToken_internalError"
	ReportsEndpointErrorCodesActionTokenInvalid               ReportsEndpointErrorCodes = "actionToken_invalid"
	ReportsEndpointErrorCodesActionTokenMissing               ReportsEndpointErrorCodes = "actionToken_missing"
	ReportsEndpointErrorCodesActionTokenUnknownType           ReportsEndpointErrorCodes = "actionToken_unknownType"
	ReportsEndpointErrorCodesAlreadyExists                    ReportsEndpointErrorCodes = "already_exists"
	ReportsEndpointErrorCodesAuthenticationBase64DecodeFailed ReportsEndpointErrorCodes = "authentication_base64DecodeFailed"
	ReportsEndpointErrorCodesAuthenticationInternalError      ReportsEndpointErrorCodes = "authentication_internalError"
	ReportsEndpointErrorCodesAuthenticationInvalidCredentials ReportsEndpointErrorCodes = "authentication_invalid_credentials"
	ReportsEndpointErrorCodesAuthenticationMethodNotSupported ReportsEndpointErrorCodes = "authentication_methodNotSupported"
	ReportsEndpointErrorCodesAuthenticationMissing            ReportsEndpointErrorCodes = "authentication_missing"
	ReportsEndpointErrorCodesAuthenticationUserDisabled       ReportsEndpointErrorCodes = "authentication_userDisabled"
	ReportsEndpointErrorCodesAuthorizationNoPermission        ReportsEndpointErrorCodes = "authorization_noPermission"
	ReportsEndpointErrorCodesContainerIdInvalid               ReportsEndpointErrorCodes = "containerId_invalid"
	ReportsEndpointErrorCodesContainerIdMissing               ReportsEndpointErrorCodes = "containerId_missing"
	ReportsEndpointErrorCodesFieldDeprecated                  ReportsEndpointErrorCodes = "field_deprecated"
	ReportsEndpointErrorCodesMandatoryEmailSendingFailed      ReportsEndpointErrorCodes = "mandatoryEmailSending_failed"
	ReportsEndpointErrorCodesQueryLimitReached                ReportsEndpointErrorCodes = "query_limit_reached"
	ReportsEndpointErrorCodesReportInstanceIdInvalid          ReportsEndpointErrorCodes = "reportInstanceId_invalid"
	ReportsEndpointErrorCodesReportSetupExists                ReportsEndpointErrorCodes = "reportSetup_exists"
	ReportsEndpointErrorCodesReportSetupIdInvalid             ReportsEndpointErrorCodes = "reportSetupId_invalid"
	ReportsEndpointErrorCodesRequestDataContradicting         ReportsEndpointErrorCodes = "requestData_contradicting"
	ReportsEndpointErrorCodesRequestDataInvalid               ReportsEndpointErrorCodes = "requestData_invalid"
	ReportsEndpointErrorCodesRequestDataMissing               ReportsEndpointErrorCodes = "requestData_missing"
	ReportsEndpointErrorCodesRequestDataNotSupported          ReportsEndpointErrorCodes = "requestData_not_supported"
	ReportsEndpointErrorCodesRequestDataWrongFormat           ReportsEndpointErrorCodes = "requestData_wrongFormat"
	ReportsEndpointErrorCodesRequestParameterConflict         ReportsEndpointErrorCodes = "requestParameter_conflict"
	ReportsEndpointErrorCodesRequestParameterContradicting    ReportsEndpointErrorCodes = "requestParameter_contradicting"
	ReportsEndpointErrorCodesRequestParameterInvalid          ReportsEndpointErrorCodes = "requestParameter_invalid"
	ReportsEndpointErrorCodesRequestParameterMissing          ReportsEndpointErrorCodes = "requestParameter_missing"
	ReportsEndpointErrorCodesRequestParameterNotSupported     ReportsEndpointErrorCodes = "requestParameter_not_supported"
	ReportsEndpointErrorCodesRequestParameterPointless        ReportsEndpointErrorCodes = "requestParameter_pointless"
	ReportsEndpointErrorCodesRequestParameterWrongFormat      ReportsEndpointErrorCodes = "requestParameter_wrongFormat"
	ReportsEndpointErrorCodesResourceDataConflict             ReportsEndpointErrorCodes = "resourceData_conflict"
	ReportsEndpointErrorCodesResourceDataContradicting        ReportsEndpointErrorCodes = "resourceData_contradicting"
	ReportsEndpointErrorCodesResourceDataInvalid              ReportsEndpointErrorCodes = "resourceData_invalid"
	ReportsEndpointErrorCodesResourceDataMissing              ReportsEndpointErrorCodes = "resourceData_missing"
	ReportsEndpointErrorCodesResourceDataNotSupported         ReportsEndpointErrorCodes = "resourceData_not_supported"
	ReportsEndpointErrorCodesResourceDataPointless            ReportsEndpointErrorCodes = "resourceData_pointless"
	ReportsEndpointErrorCodesResourceDataWrongFormat          ReportsEndpointErrorCodes = "resourceData_wrongFormat"
	ReportsEndpointErrorCodesResourceVersionMismatch          ReportsEndpointErrorCodes = "resourceVersion_mismatch"
	ReportsEndpointErrorCodesUnderlyingResourceUnavailable    ReportsEndpointErrorCodes = "underlying_resource_unavailable"
	ReportsEndpointErrorCodesUrlInvalid                       ReportsEndpointErrorCodes = "url_invalid"
)

// Defines values for ReportsEndpointLocalErrorCodes.
const (
	ReportsEndpointLocalErrorCodesContainerIdInvalid      ReportsEndpointLocalErrorCodes = "containerId_invalid"
	ReportsEndpointLocalErrorCodesContainerIdMissing      ReportsEndpointLocalErrorCodes = "containerId_missing"
	ReportsEndpointLocalErrorCodesReportInstanceIdInvalid ReportsEndpointLocalErrorCodes = "reportInstanceId_invalid"
	ReportsEndpointLocalErrorCodesReportSetupExists       ReportsEndpointLocalErrorCodes = "reportSetup_exists"
	ReportsEndpointLocalErrorCodesReportSetupIdInvalid    ReportsEndpointLocalErrorCodes = "reportSetupId_invalid"
)

// DataTable DataTable is the output of queries - a self contained table of data with Axis columns (optional) and >1 Data columns. Plus of course the data rows.
type DataTable struct {
	// Columns List of "Axis" columns. Order in array is important as the index of the entry tells the position.
	Columns []DataTableColumn `json:"columns" yaml:"columns"`
	Rows    *[]DataTableRow   `json:"rows,omitempty" yaml:"rows,omitempty"`
}

// DataTableAxisColumn defines model for DataTableAxisColumn.
type DataTableAxisColumn struct {
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`
}

// DataTableCell defines model for DataTableCell.
type DataTableCell struct {
	union json.RawMessage
}

// DataTableCell0 defines model for .
type DataTableCell0 = string

// DataTableCell1 defines model for .
type DataTableCell1 = float32

// DataTableColumn defines model for DataTableColumn.
type DataTableColumn struct {
	union json.RawMessage
}

// DataTableDataColumn defines model for DataTableDataColumn.
type DataTableDataColumn struct {
	CollapseFunction *string `json:"collapseFunction,omitempty" yaml:"collapseFunction,omitempty"`
	Label            *string `json:"label,omitempty" yaml:"label,omitempty"`
}

// DataTableRow defines model for DataTableRow.
type DataTableRow = []DataTableCell

// GenerateReportRequestClass defines model for GenerateReportRequestClass.
type GenerateReportRequestClass struct {
	// ExecuteQueryIdsOnly A report might contain multiple ReportQuery parts, all of them has its unique ID within the report.
	// It is possible to generate only specific queries instead of the full report - by providing a list of those ReportQuery IDs here.
	// **BUT** if you do this, then this also sets 'isTestOnly' to TRUE! So the generated ReportInstance considered to be a test only.
	ExecuteQueryIdsOnly *[]string `json:"executeQueryIdsOnly,omitempty" yaml:"executeQueryIdsOnly,omitempty"`

	// FromTimestamp When executed manually (not scheduled way) defines the beginning of the query range - you are interested in data which time is >= than this timestamp.
	//
	// Format is mixed. It can be * a UNIX timestamp in UTC (seconds since Epoch) e.g.: `1657261221` - means 2022-07-08 6:20:21 GMT
	//   (note: server and client clock might be different! see: /v2/system/clock endpoint to query server time)
	// * a relative time spec compared to current time in form of 'now[-X<m|h|d>]' where 'm' means minutes, 'h' means hours and 'd' means days,
	//   e.g.: `now-10m` means 10 minutes earlier compared to current time,
	//   `now-2h` means 2 hours earlier and so on
	//
	// This must point to the past!   (note: server validates according to his own clock!)
	FromTimestamp *string `json:"fromTimestamp,omitempty" yaml:"fromTimestamp,omitempty"`

	// IsTestOnly Set it to TRUE if you just want to test the report generation.
	// In this case the recipients (if set in report setup) will not be notified about this report at all. And only the user who generated it will receive a notification when report is ready to view. But apart from this the full report will be generated.
	IsTestOnly *bool `json:"isTestOnly,omitempty" yaml:"isTestOnly,omitempty"`

	// SkipNotifications If this is set to TRUE then recipients will not receive any notification from Keytiles when this Report Instance is created.
	// **IMPORTANT!** Use this with caution! This option was introduced mostly because of internal reasons under certain circumstances.
	SkipNotifications *bool `json:"skipNotifications,omitempty" yaml:"skipNotifications,omitempty"`

	// ToTimestamp When executed manually (not scheduled way) defines the end of the query range - you are interested in data which time is <= than this timestamp.
	//
	// **Default value:** the current timestamp, so 'now' if you do not specify this parameter.
	//
	// Format is mixed. It can be * a UNIX timestamp in UTC (seconds since Epoch) e.g.: `1657261221` - means 2022-07-08 6:20:21 GMT
	//   (note: server and client clock might be different! see: /v2/system/clock endpoint to query server time)
	// * a relative time spec compared to current time in form of 'now[-X<m|h|d>]' where 'm' means minutes, 'h' means hours and 'd' means days,
	//   e.g.: `now-10m` means 10 minutes earlier compared to current time,
	//   `now-2h` means 2 hours earlier and so on
	//
	// Can not point to the future!   (note: server validates according to his own clock!)
	ToTimestamp *string `json:"toTimestamp,omitempty" yaml:"toTimestamp,omitempty"`
}

// GetContainerReportInstanceResponseClass defines model for GetContainerReportInstanceResponseClass.
type GetContainerReportInstanceResponseClass = externalRef2.ContainerResponseV3Class

// GetContainerReportSetupResponseClass defines model for GetContainerReportSetupResponseClass.
type GetContainerReportSetupResponseClass = externalRef2.ContainerResponseV3Class

// ListContainerReportInstancesResponseClass defines model for ListContainerReportInstancesResponseClass.
type ListContainerReportInstancesResponseClass = externalRef2.ContainerResponseV3Class

// ListContainerReportSetupsResponseClass Overview of all avaiable report setups.
type ListContainerReportSetupsResponseClass = []ReportSetupOverview

// ListReportInstancesRequestClass You can fine tune how the list is generated with the attributes of this request.
type ListReportInstancesRequestClass struct {
	// ExcludeNotTestOnlyInstances By default the request includes normal (not "test only") instances - unless you request here to exclude them
	ExcludeNotTestOnlyInstances *bool `json:"excludeNotTestOnlyInstances,omitempty" yaml:"excludeNotTestOnlyInstances,omitempty"`

	// IncludeTestOnlyInstances By default the request excludes the "test only" instances - unless you request here to include them
	IncludeTestOnlyInstances *bool `json:"includeTestOnlyInstances,omitempty" yaml:"includeTestOnlyInstances,omitempty"`
}

// ReportInstance This is a specific instance of a ReportSetup which was generated at a certain point in time. Keytiles stores these reports for a while.
// A report instance consists of sections - each section is generated by a query.
type ReportInstance struct {
	// CreatedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
	CreatedAt *int32 `json:"createdAt,omitempty" yaml:"createdAt,omitempty"`

	// FromTimestamp Query range - starting from this timestamp. This is a UNIX timestamp in UTC (seconds since Epoch) e.g.: 1657261221 - means 2022-07-08 6:20:21 GMT
	FromTimestamp *int `json:"fromTimestamp,omitempty" yaml:"fromTimestamp,omitempty"`

	// Id The unique ID of this report setup - UUID style
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// IsTestOnly Tells if this report instance is a result of a test generation only or not.
	IsTestOnly *bool                  `json:"isTestOnly,omitempty" yaml:"isTestOnly,omitempty"`
	MetaData   *externalRef0.MetaData `json:"metaData,omitempty" yaml:"metaData,omitempty"`

	// ParentReportSetupId The ID of the ReportSetup this instance belongs to.
	ParentReportSetupId *string                  `json:"parentReportSetupId,omitempty" yaml:"parentReportSetupId,omitempty"`
	Sections            *[]ReportInstanceSection `json:"sections,omitempty" yaml:"sections,omitempty"`

	// State It takes time for a report instance until it is fully generated. So every report instance is going through a lifecycle.
	// This is maintained by the server.
	State *ReportInstanceState `json:"state,omitempty" yaml:"state,omitempty"`

	// ToTimestamp Query range - until this timestamp. This is a UNIX timestamp in UTC (seconds since Epoch) e.g.: 1657261221 - means 2022-07-08 6:20:21 GMT
	ToTimestamp *int `json:"toTimestamp,omitempty" yaml:"toTimestamp,omitempty"`
}

// ReportInstanceOverview Contains minimalistic information about an existing instance of a report setup - like its ID, creation time, parent report setup ID, etc. It is a quick overview.
type ReportInstanceOverview struct {
	// CreatedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
	CreatedAt *int32 `json:"createdAt,omitempty" yaml:"createdAt,omitempty"`

	// FromTimestamp Query range - starting from this timestamp. This is a UNIX timestamp in UTC (seconds since Epoch) e.g.: 1657261221 - means 2022-07-08 6:20:21 GMT
	FromTimestamp *int    `json:"fromTimestamp,omitempty" yaml:"fromTimestamp,omitempty"`
	Id            *string `json:"id,omitempty" yaml:"id,omitempty"`

	// IsTestOnly Tells if this report instance is marked as 'test only' or not.
	IsTestOnly *bool `json:"isTestOnly,omitempty" yaml:"isTestOnly,omitempty"`

	// ParentReportSetupId The ID of the report setup this instance belongs to
	ParentReportSetupId *string `json:"parentReportSetupId,omitempty" yaml:"parentReportSetupId,omitempty"`

	// ToTimestamp Query range - until this timestamp. This is a UNIX timestamp in UTC (seconds since Epoch) e.g.: 1657261221 - means 2022-07-08 6:20:21 GMT
	ToTimestamp *int `json:"toTimestamp,omitempty" yaml:"toTimestamp,omitempty"`
}

// ReportInstanceSection defines model for ReportInstanceSection.
type ReportInstanceSection struct {
	DataTables *[]DataTable `json:"dataTables,omitempty" yaml:"dataTables,omitempty"`

	// Description This is a longer description of this section - copied from the ReportSetup appropriate Query part which produced this section when this instance was generated.
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// State It takes time for a report until it is fully generated. Report sections are going through a lifecycle and these are their states.
	State *ReportInstanceSectionState `json:"state,omitempty" yaml:"state,omitempty"`

	// Title The title of this section - copied from the ReportSetup appropriate Query part which produced this section when this instance was generated.
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// ReportInstanceSectionState It takes time for a report until it is fully generated. Report sections are going through a lifecycle and these are their states.
type ReportInstanceSectionState string

// ReportInstanceState It takes time for a report instance until it is fully generated. So every report instance is going through a lifecycle.
// This is maintained by the server.
type ReportInstanceState string

// ReportQuery A report can contain multiple queries. This object describes one query of those.
type ReportQuery struct {
	// Id The unique ID (within the report) of this query - UUID style. In concrete report instances this helps to identify the result of this query within the whole report.
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// IsDisabled It is possible to temporarily disable a query. This way you do not lose its setup, so you can re-enable it later again.
	IsDisabled *bool                 `json:"isDisabled,omitempty" yaml:"isDisabled,omitempty"`
	MetaData   externalRef0.MetaData `json:"metaData" yaml:"metaData"`

	// Parameters The parameters a query plugin needs depends on the plugin. These key-value pairs provide the setup how the query plugin will generate this part of the report.
	Parameters *ReportQuery_Parameters `json:"parameters,omitempty" yaml:"parameters,omitempty"`
	Plugin     ReportQueryPlugin       `json:"plugin" yaml:"plugin"`
}

// ReportQuery_Parameters The parameters a query plugin needs depends on the plugin. These key-value pairs provide the setup how the query plugin will generate this part of the report.
type ReportQuery_Parameters struct {
	// EventsIncluded Which event counts to include into the report? E.g. "pageview", or custom events e.g. "30 seconds passed". These will be the columns in your report. You can also construct formulas using the pure eventNames.
	EventsIncluded *[]string `json:"eventsIncluded,omitempty" yaml:"eventsIncluded,omitempty"`

	// GroupByTileGroupPathMaxDepth You can limit how deep you want the report to go down in the content structure. E.g. if you set it to 1 that means you get a break down only for first level.
	GroupByTileGroupPathMaxDepth *int `json:"groupByTileGroupPathMaxDepth,omitempty" yaml:"groupByTileGroupPathMaxDepth,omitempty"`

	// GroupByTileGroupPaths If set to TRUE then you get a break-down based on content structure (=tileGroupPath). Can not be used together with 'groupByTiles'!
	GroupByTileGroupPaths *bool `json:"groupByTileGroupPaths,omitempty" yaml:"groupByTileGroupPaths,omitempty"`

	// GroupByTiles If set to TRUE then you get a break-down on Tile level - otherwise just sum of the traffic of all Tiles.
	GroupByTiles *bool `json:"groupByTiles,omitempty" yaml:"groupByTiles,omitempty"`

	// GroupByTime If set to TRUE then you get a break-down in time interval. The interval is driven by your schedule.
	//  * Hourly schedule: you get 15 minutes break-down
	//  * Daily schedule: you get an hourly breakdown
	//  * Weekly schedule: you get a daily breakdown
	//  * Monthly schedule: you get a weekly breakdown
	GroupByTime *bool `json:"groupByTime,omitempty" yaml:"groupByTime,omitempty"`

	// Limit Optional param. How many rows you want to display maximum? Only makes sense if 'groupByTiles=true' or 'groupByTileGroupPaths=true'. Using the 'performanceDescendingOrder' basically you can see the top performing ones, or the worst performing ones - up to you.
	Limit                      *int  `json:"limit,omitempty" yaml:"limit,omitempty"`
	PerformanceDescendingOrder *bool `json:"performanceDescendingOrder,omitempty" yaml:"performanceDescendingOrder,omitempty"`

	// SortBy Sort the list based on these "eventsIncluded"
	SortBy *[]string `json:"sortBy,omitempty" yaml:"sortBy,omitempty"`

	// TileGroupPathMatchingOnly Data filter option. Comma separated list of matchers (see below) which returns counters only for those Tiles who's tileGroupPath is matching to one of the listed matchers. So if you list more values here then they are interpreted with an OR operator.
	//
	// note: if you have comma in your matcher (strange, but ok...) you can escape that with `\\` character!
	//
	// You can use the **'\*'** character to match any substring. But where and how you put this Asterisk character matters! Let us show you how through an example!
	// Let's assume you have articles and pages (Tiles) in the following content areas:
	//
	// * /auto * /tech * /tech/mobile-rumours * /tech/mobile * /tech/mobile/android * /tech/mobile/ios * /politics
	//
	// And now you execute queries with two different **tileGroupPathMatchingOnly** settings: 1. **"/tech/mobile\*"** and 1. **"/tech/mobile/\*"**
	// In the first query **"/tech/mobile\*"** would match for everything begins with "/tech/mobile" string. So this would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* Tiles but also would include *"/tech/mobile-rumours"* Tiles. Which are clearly two different areas right?
	//
	// But what if you want to really limit for Tiles under the *"/tech/mobile"* area?
	//
	// Well then you can use the second query value: **"/tech/mobile/\*"**. This would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* but would NOT include *"/tech/mobile-rumours"* anymore - as that is not a match anymore. But we are not done yet! Please note: this would also include Tiles under *"/tech/mobile/"* group itself. Because **"/\*"** means "everything which is under this group"
	TileGroupPathMatchingOnly *string `json:"tileGroupPathMatchingOnly,omitempty" yaml:"tileGroupPathMatchingOnly,omitempty"`

	// TileTypesOnly Data filter option. Comma separated list of tile types you want to limit the query for. If you list more values here then they are interpreted with an OR operator.
	//
	// IMPORTANT! You can not use this together with `tileTypeIsNot` parameter! You can only use this or that but not both.
	//
	// In the list you can either use: * The name of the type ('frontpage', 'page', 'article', ...), or * The numeric ID of the tile type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
	TileTypesOnly        *string                `json:"tileTypesOnly,omitempty" yaml:"tileTypesOnly,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReportQueryPlugin defines model for ReportQueryPlugin.
type ReportQueryPlugin string

// ReportRecipients This is an optional setup - controlls who will receive these reports.
//
// If not given at all then ALL Data Container users will get the report. Otherwise if given then Keytiles users who are matching to ANY of the given criteria will receive the report.
type ReportRecipients struct {
	// Roles Optional entry. All Data Container users who has ANY of the listed roles will receive this report.
	Roles *[]ReportRecipientsRoles `json:"roles,omitempty" yaml:"roles,omitempty"`

	// Users Optional entry. List of specific Keytiles users (email or ID) to send the reports to. The users who are listed here will get the reports for sure if
	//  * they are not disabled in Keytiles (can not log in)
	//  * they are not associated with the Data Container anyhow
	Users *[]string `json:"users,omitempty" yaml:"users,omitempty"`
}

// ReportRecipientsRoles defines model for ReportRecipientsRoles.
type ReportRecipientsRoles string

// ReportSetup defines model for ReportSetup.
type ReportSetup struct {
	// CreatedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this setup was created
	CreatedAt int32 `json:"createdAt" yaml:"createdAt"`

	// Id The unique ID of this report setup - UUID style
	Id string `json:"id" yaml:"id"`

	// IsDisabled It is possible to temporarily disable a report. The report is still generatable manually but automatic schedules will not be executed.
	IsDisabled bool                  `json:"isDisabled" yaml:"isDisabled"`
	MetaData   externalRef0.MetaData `json:"metaData" yaml:"metaData"`

	// Queries Queries of this report.
	Queries *[]ReportQuery `json:"queries" yaml:"queries"`

	// Recipients This is an optional setup - controlls who will receive these reports.
	//
	// If not given at all then ALL Data Container users will get the report. Otherwise if given then Keytiles users who are matching to ANY of the given criteria will receive the report.
	Recipients *ReportRecipients `json:"recipients" yaml:"recipients"`

	// ResourceVersion This is the resource version (which is automatically incremented by every change). When you do an update (PUT) you need to send it back! The server will check if it is matching with the resource version he has. If not then that means someone else already did an update in the meantime therefore your request can not be accepted - otherwise you may overwrite the changes someone did.
	ResourceVersion int `json:"resourceVersion" yaml:"resourceVersion"`

	// Schedule Describes a Schedule of something. As of now you have basically 4 types: hourly, daily, weekly and Monthly schedules.
	Schedule *externalRef1.Schedule `json:"schedule" yaml:"schedule"`
}

// ReportSetupOverview Contains minimalistic information about an existing report setup - like its ID, title, description, creation time, schedule. It is a quick overview.
// By default the `changelog` within `metaData` only contains the first and very last item. You might request more - see request parameters!
type ReportSetupOverview struct {
	// CreatedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
	CreatedAt int32 `json:"createdAt" yaml:"createdAt"`

	// Id The unique ID of this report setup - UUID style
	Id string `json:"id" yaml:"id"`

	// IsDisabled It is possible to temporarily disable a report. The report is still generatable manually but automatic schedules will not be executed.
	IsDisabled bool                  `json:"isDisabled" yaml:"isDisabled"`
	MetaData   externalRef0.MetaData `json:"metaData" yaml:"metaData"`

	// Schedule Describes a Schedule of something. As of now you have basically 4 types: hourly, daily, weekly and Monthly schedules.
	Schedule *externalRef1.Schedule `json:"schedule" yaml:"schedule"`
}

// ReportsEndpointErrorCodes defines model for ReportsEndpointErrorCodes.
type ReportsEndpointErrorCodes string

// ReportsEndpointLocalErrorCodes defines model for ReportsEndpointLocalErrorCodes.
type ReportsEndpointLocalErrorCodes string

// ReportInstanceId defines model for reportInstanceId.
type ReportInstanceId = string

// ReportSetupId defines model for reportSetupId.
type ReportSetupId = string

// PostV1ReportsContainersRestContainerIdReportSetupParams defines parameters for PostV1ReportsContainersRestContainerIdReportSetup.
type PostV1ReportsContainersRestContainerIdReportSetupParams struct {
	// ChangelogComment Short user message which if sent then added to the changelog entry created by the server.
	ChangelogComment *externalRef2.ChangelogComment `form:"changelogComment,omitempty" json:"changelogComment,omitempty" yaml:"changelogComment,omitempty"`
}

// GetV1ReportsContainersRestContainerIdReportSetupOverviewParams defines parameters for GetV1ReportsContainersRestContainerIdReportSetupOverview.
type GetV1ReportsContainersRestContainerIdReportSetupOverviewParams struct {
	// ReturnFullChangelog By default returned `changelog` in meta data only contains the very first and last entries upon query - but you can request to return full changelog.
	//
	// **Default value:** false
	ReturnFullChangelog *externalRef2.ReturnFullChangelog `form:"returnFullChangelog,omitempty" json:"returnFullChangelog,omitempty" yaml:"returnFullChangelog,omitempty"`
}

// GetV1ReportsContainersRestContainerIdReportSetupReportSetupIdParams defines parameters for GetV1ReportsContainersRestContainerIdReportSetupReportSetupId.
type GetV1ReportsContainersRestContainerIdReportSetupReportSetupIdParams struct {
	// ReturnFullChangelog By default returned `changelog` in meta data only contains the very first and last entries upon query - but you can request to return full changelog.
	//
	// **Default value:** false
	ReturnFullChangelog *externalRef2.ReturnFullChangelog `form:"returnFullChangelog,omitempty" json:"returnFullChangelog,omitempty" yaml:"returnFullChangelog,omitempty"`
}

// PutV1ReportsContainersRestContainerIdReportSetupReportSetupIdParams defines parameters for PutV1ReportsContainersRestContainerIdReportSetupReportSetupId.
type PutV1ReportsContainersRestContainerIdReportSetupReportSetupIdParams struct {
	// ChangelogComment Short user message which if sent then added to the changelog entry created by the server.
	ChangelogComment *externalRef2.ChangelogComment `form:"changelogComment,omitempty" json:"changelogComment,omitempty" yaml:"changelogComment,omitempty"`

	// ReturnFullChangelog By default returned `changelog` in meta data only contains the very first and last entries upon query - but you can request to return full changelog.
	//
	// **Default value:** false
	ReturnFullChangelog *externalRef2.ReturnFullChangelog `form:"returnFullChangelog,omitempty" json:"returnFullChangelog,omitempty" yaml:"returnFullChangelog,omitempty"`
}

// PostV1ReportsContainersActionsContainerIdReportSetupReportSetupIdGenerateJSONRequestBody defines body for PostV1ReportsContainersActionsContainerIdReportSetupReportSetupIdGenerate for application/json ContentType.
type PostV1ReportsContainersActionsContainerIdReportSetupReportSetupIdGenerateJSONRequestBody = GenerateReportRequestClass

// PostV1ReportsContainersActionsContainerIdReportSetupReportSetupIdListReportInstanceOverviewJSONRequestBody defines body for PostV1ReportsContainersActionsContainerIdReportSetupReportSetupIdListReportInstanceOverview for application/json ContentType.
type PostV1ReportsContainersActionsContainerIdReportSetupReportSetupIdListReportInstanceOverviewJSONRequestBody = ListReportInstancesRequestClass

// PostV1ReportsContainersRestContainerIdReportSetupJSONRequestBody defines body for PostV1ReportsContainersRestContainerIdReportSetup for application/json ContentType.
type PostV1ReportsContainersRestContainerIdReportSetupJSONRequestBody = ReportSetup

// PutV1ReportsContainersRestContainerIdReportSetupReportSetupIdJSONRequestBody defines body for PutV1ReportsContainersRestContainerIdReportSetupReportSetupId for application/json ContentType.
type PutV1ReportsContainersRestContainerIdReportSetupReportSetupIdJSONRequestBody = ReportSetup

// Getter for additional properties for ReportQuery_Parameters. Returns the specified
// element and whether it was found
func (a ReportQuery_Parameters) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ReportQuery_Parameters
func (a *ReportQuery_Parameters) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ReportQuery_Parameters to handle AdditionalProperties
func (a *ReportQuery_Parameters) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["eventsIncluded"]; found {
		err = json.Unmarshal(raw, &a.EventsIncluded)
		if err != nil {
			return fmt.Errorf("error reading 'eventsIncluded': %w", err)
		}
		delete(object, "eventsIncluded")
	}

	if raw, found := object["groupByTileGroupPathMaxDepth"]; found {
		err = json.Unmarshal(raw, &a.GroupByTileGroupPathMaxDepth)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTileGroupPathMaxDepth': %w", err)
		}
		delete(object, "groupByTileGroupPathMaxDepth")
	}

	if raw, found := object["groupByTileGroupPaths"]; found {
		err = json.Unmarshal(raw, &a.GroupByTileGroupPaths)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTileGroupPaths': %w", err)
		}
		delete(object, "groupByTileGroupPaths")
	}

	if raw, found := object["groupByTiles"]; found {
		err = json.Unmarshal(raw, &a.GroupByTiles)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTiles': %w", err)
		}
		delete(object, "groupByTiles")
	}

	if raw, found := object["groupByTime"]; found {
		err = json.Unmarshal(raw, &a.GroupByTime)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTime': %w", err)
		}
		delete(object, "groupByTime")
	}

	if raw, found := object["limit"]; found {
		err = json.Unmarshal(raw, &a.Limit)
		if err != nil {
			return fmt.Errorf("error reading 'limit': %w", err)
		}
		delete(object, "limit")
	}

	if raw, found := object["performanceDescendingOrder"]; found {
		err = json.Unmarshal(raw, &a.PerformanceDescendingOrder)
		if err != nil {
			return fmt.Errorf("error reading 'performanceDescendingOrder': %w", err)
		}
		delete(object, "performanceDescendingOrder")
	}

	if raw, found := object["sortBy"]; found {
		err = json.Unmarshal(raw, &a.SortBy)
		if err != nil {
			return fmt.Errorf("error reading 'sortBy': %w", err)
		}
		delete(object, "sortBy")
	}

	if raw, found := object["tileGroupPathMatchingOnly"]; found {
		err = json.Unmarshal(raw, &a.TileGroupPathMatchingOnly)
		if err != nil {
			return fmt.Errorf("error reading 'tileGroupPathMatchingOnly': %w", err)
		}
		delete(object, "tileGroupPathMatchingOnly")
	}

	if raw, found := object["tileTypesOnly"]; found {
		err = json.Unmarshal(raw, &a.TileTypesOnly)
		if err != nil {
			return fmt.Errorf("error reading 'tileTypesOnly': %w", err)
		}
		delete(object, "tileTypesOnly")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ReportQuery_Parameters to handle AdditionalProperties
func (a ReportQuery_Parameters) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EventsIncluded != nil {
		object["eventsIncluded"], err = json.Marshal(a.EventsIncluded)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eventsIncluded': %w", err)
		}
	}

	if a.GroupByTileGroupPathMaxDepth != nil {
		object["groupByTileGroupPathMaxDepth"], err = json.Marshal(a.GroupByTileGroupPathMaxDepth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTileGroupPathMaxDepth': %w", err)
		}
	}

	if a.GroupByTileGroupPaths != nil {
		object["groupByTileGroupPaths"], err = json.Marshal(a.GroupByTileGroupPaths)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTileGroupPaths': %w", err)
		}
	}

	if a.GroupByTiles != nil {
		object["groupByTiles"], err = json.Marshal(a.GroupByTiles)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTiles': %w", err)
		}
	}

	if a.GroupByTime != nil {
		object["groupByTime"], err = json.Marshal(a.GroupByTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTime': %w", err)
		}
	}

	if a.Limit != nil {
		object["limit"], err = json.Marshal(a.Limit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit': %w", err)
		}
	}

	if a.PerformanceDescendingOrder != nil {
		object["performanceDescendingOrder"], err = json.Marshal(a.PerformanceDescendingOrder)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'performanceDescendingOrder': %w", err)
		}
	}

	if a.SortBy != nil {
		object["sortBy"], err = json.Marshal(a.SortBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sortBy': %w", err)
		}
	}

	if a.TileGroupPathMatchingOnly != nil {
		object["tileGroupPathMatchingOnly"], err = json.Marshal(a.TileGroupPathMatchingOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tileGroupPathMatchingOnly': %w", err)
		}
	}

	if a.TileTypesOnly != nil {
		object["tileTypesOnly"], err = json.Marshal(a.TileTypesOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tileTypesOnly': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsDataTableCell0 returns the union data inside the DataTableCell as a DataTableCell0
func (t DataTableCell) AsDataTableCell0() (DataTableCell0, error) {
	var body DataTableCell0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableCell0 overwrites any union data inside the DataTableCell as the provided DataTableCell0
func (t *DataTableCell) FromDataTableCell0(v DataTableCell0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsDataTableCell1 returns the union data inside the DataTableCell as a DataTableCell1
func (t DataTableCell) AsDataTableCell1() (DataTableCell1, error) {
	var body DataTableCell1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableCell1 overwrites any union data inside the DataTableCell as the provided DataTableCell1
func (t *DataTableCell) FromDataTableCell1(v DataTableCell1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DataTableCell) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataTableCell) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDataTableAxisColumn returns the union data inside the DataTableColumn as a DataTableAxisColumn
func (t DataTableColumn) AsDataTableAxisColumn() (DataTableAxisColumn, error) {
	var body DataTableAxisColumn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableAxisColumn overwrites any union data inside the DataTableColumn as the provided DataTableAxisColumn
func (t *DataTableColumn) FromDataTableAxisColumn(v DataTableAxisColumn) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsDataTableDataColumn returns the union data inside the DataTableColumn as a DataTableDataColumn
func (t DataTableColumn) AsDataTableDataColumn() (DataTableDataColumn, error) {
	var body DataTableDataColumn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableDataColumn overwrites any union data inside the DataTableColumn as the provided DataTableDataColumn
func (t *DataTableColumn) FromDataTableDataColumn(v DataTableDataColumn) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DataTableColumn) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataTableColumn) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
