// Package kt_pubapi_gen_reportsv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package kt_pubapi_gen_reportsv1

import (
	"encoding/json"
	"fmt"

	externalRef0 "github.com/keytiles/keytiles-public-api/gopkg/model/generated/common/metadata_v1"
	externalRef1 "github.com/keytiles/keytiles-public-api/gopkg/model/generated/common/schedule_v1"
	externalRef2 "github.com/keytiles/keytiles-public-api/gopkg/model/generated/common/types_v3"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for ReportQueryPlugin.
const (
	CampaignPerformancePlugin ReportQueryPlugin = "campaignPerformancePlugin"
	EventCountPlugin          ReportQueryPlugin = "eventCountPlugin"
	LinksPerformancePlugin    ReportQueryPlugin = "linksPerformancePlugin"
	SocialPerformancePlugin   ReportQueryPlugin = "socialPerformancePlugin"
	TagsPerformancePlugin     ReportQueryPlugin = "tagsPerformancePlugin"
	VisitorBehaviorPlugin     ReportQueryPlugin = "visitorBehaviorPlugin"
)

// Defines values for ReportRecipientsRoles.
const (
	Admin     ReportRecipientsRoles = "admin"
	Developer ReportRecipientsRoles = "developer"
	View      ReportRecipientsRoles = "view"
)

// Defines values for ReportsEndpointErrorCodes.
const (
	ReportsEndpointErrorCodesActionTokenInternalError         ReportsEndpointErrorCodes = "actionToken_internalError"
	ReportsEndpointErrorCodesActionTokenInvalid               ReportsEndpointErrorCodes = "actionToken_invalid"
	ReportsEndpointErrorCodesActionTokenMissing               ReportsEndpointErrorCodes = "actionToken_missing"
	ReportsEndpointErrorCodesActionTokenUnknownType           ReportsEndpointErrorCodes = "actionToken_unknownType"
	ReportsEndpointErrorCodesAuthenticationBase64DecodeFailed ReportsEndpointErrorCodes = "authentication_base64DecodeFailed"
	ReportsEndpointErrorCodesAuthenticationInternalError      ReportsEndpointErrorCodes = "authentication_internalError"
	ReportsEndpointErrorCodesAuthenticationInvalidCredentials ReportsEndpointErrorCodes = "authentication_invalid_credentials"
	ReportsEndpointErrorCodesAuthenticationMethodNotSupported ReportsEndpointErrorCodes = "authentication_methodNotSupported"
	ReportsEndpointErrorCodesAuthenticationMissing            ReportsEndpointErrorCodes = "authentication_missing"
	ReportsEndpointErrorCodesAuthenticationUserDisabled       ReportsEndpointErrorCodes = "authentication_userDisabled"
	ReportsEndpointErrorCodesAuthorizationNoPermission        ReportsEndpointErrorCodes = "authorization_noPermission"
	ReportsEndpointErrorCodesContainerIdInvalid               ReportsEndpointErrorCodes = "containerId_invalid"
	ReportsEndpointErrorCodesContainerIdMissing               ReportsEndpointErrorCodes = "containerId_missing"
	ReportsEndpointErrorCodesFieldDeprecated                  ReportsEndpointErrorCodes = "field_deprecated"
	ReportsEndpointErrorCodesMandatoryEmailSendingFailed      ReportsEndpointErrorCodes = "mandatoryEmailSending_failed"
	ReportsEndpointErrorCodesQueryLimitReached                ReportsEndpointErrorCodes = "query_limit_reached"
	ReportsEndpointErrorCodesReportSetupIdInvalid             ReportsEndpointErrorCodes = "reportSetupId_invalid"
	ReportsEndpointErrorCodesRequestDataContradicting         ReportsEndpointErrorCodes = "requestData_contradicting"
	ReportsEndpointErrorCodesRequestDataInvalid               ReportsEndpointErrorCodes = "requestData_invalid"
	ReportsEndpointErrorCodesRequestDataMissing               ReportsEndpointErrorCodes = "requestData_missing"
	ReportsEndpointErrorCodesRequestDataNotSupported          ReportsEndpointErrorCodes = "requestData_not_supported"
	ReportsEndpointErrorCodesRequestDataWrongFormat           ReportsEndpointErrorCodes = "requestData_wrongFormat"
	ReportsEndpointErrorCodesRequestParameterConflict         ReportsEndpointErrorCodes = "requestParameter_conflict"
	ReportsEndpointErrorCodesRequestParameterContradicting    ReportsEndpointErrorCodes = "requestParameter_contradicting"
	ReportsEndpointErrorCodesRequestParameterInvalid          ReportsEndpointErrorCodes = "requestParameter_invalid"
	ReportsEndpointErrorCodesRequestParameterMissing          ReportsEndpointErrorCodes = "requestParameter_missing"
	ReportsEndpointErrorCodesRequestParameterNotSupported     ReportsEndpointErrorCodes = "requestParameter_not_supported"
	ReportsEndpointErrorCodesRequestParameterPointless        ReportsEndpointErrorCodes = "requestParameter_pointless"
	ReportsEndpointErrorCodesRequestParameterWrongFormat      ReportsEndpointErrorCodes = "requestParameter_wrongFormat"
	ReportsEndpointErrorCodesResourceDataConflict             ReportsEndpointErrorCodes = "resourceData_conflict"
	ReportsEndpointErrorCodesResourceDataContradicting        ReportsEndpointErrorCodes = "resourceData_contradicting"
	ReportsEndpointErrorCodesResourceDataInvalid              ReportsEndpointErrorCodes = "resourceData_invalid"
	ReportsEndpointErrorCodesResourceDataMissing              ReportsEndpointErrorCodes = "resourceData_missing"
	ReportsEndpointErrorCodesResourceDataNotSupported         ReportsEndpointErrorCodes = "resourceData_not_supported"
	ReportsEndpointErrorCodesResourceDataPointless            ReportsEndpointErrorCodes = "resourceData_pointless"
	ReportsEndpointErrorCodesResourceDataWrongFormat          ReportsEndpointErrorCodes = "resourceData_wrongFormat"
	ReportsEndpointErrorCodesResourceVersionMismatch          ReportsEndpointErrorCodes = "resourceVersion_mismatch"
	ReportsEndpointErrorCodesUnderlyingResourceUnavailable    ReportsEndpointErrorCodes = "underlying_resource_unavailable"
	ReportsEndpointErrorCodesUrlInvalid                       ReportsEndpointErrorCodes = "url_invalid"
)

// Defines values for ReportsEndpointLocalErrorCodes.
const (
	ReportsEndpointLocalErrorCodesContainerIdInvalid   ReportsEndpointLocalErrorCodes = "containerId_invalid"
	ReportsEndpointLocalErrorCodesContainerIdMissing   ReportsEndpointLocalErrorCodes = "containerId_missing"
	ReportsEndpointLocalErrorCodesReportSetupIdInvalid ReportsEndpointLocalErrorCodes = "reportSetupId_invalid"
)

// AvailableReportInstance defines model for AvailableReportInstance.
type AvailableReportInstance struct {
	// CreatedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
	CreatedAt *int32  `json:"createdAt,omitempty" yaml:"createdAt,omitempty"`
	Id        *string `json:"id,omitempty" yaml:"id,omitempty"`

	// IsTestOnly Tells if this report instance is marked as 'test only' or not.
	IsTestOnly *bool `json:"isTestOnly,omitempty" yaml:"isTestOnly,omitempty"`
}

// DataTable DataTable is the output of queries - a self contained table of data with Axis columns (optional) and >1 Data columns. Plus of course the data rows.
type DataTable struct {
	// Columns List of "Axis" columns. Order in array is important as the index of the entry tells the position.
	Columns []DataTableColumn `json:"columns" yaml:"columns"`
	Rows    *[]DataTableRow   `json:"rows,omitempty" yaml:"rows,omitempty"`
}

// DataTableAxisColumn defines model for DataTableAxisColumn.
type DataTableAxisColumn struct {
	Label *string `json:"label,omitempty" yaml:"label,omitempty"`
}

// DataTableCell defines model for DataTableCell.
type DataTableCell struct {
	union json.RawMessage
}

// DataTableCell0 defines model for .
type DataTableCell0 = string

// DataTableCell1 defines model for .
type DataTableCell1 = float32

// DataTableColumn defines model for DataTableColumn.
type DataTableColumn struct {
	union json.RawMessage
}

// DataTableDataColumn defines model for DataTableDataColumn.
type DataTableDataColumn struct {
	CollapseFunction *string `json:"collapseFunction,omitempty" yaml:"collapseFunction,omitempty"`
	Label            *string `json:"label,omitempty" yaml:"label,omitempty"`
}

// DataTableRow defines model for DataTableRow.
type DataTableRow = []DataTableCell

// GenerateReportRequestClass defines model for GenerateReportRequestClass.
type GenerateReportRequestClass struct {
	// ExecuteQueryIdsOnly A report might contain multiple ReportQuery parts, all of them has its unique ID within the report.
	// It is possible to generate only specific queries instead of the full report - by providing a list of those ReportQuery IDs here.
	// **BUT** if you do this, then this also sets 'isTestOnly' to TRUE! So the generated ReportInstance considered to be a test only.
	ExecuteQueryIdsOnly *[]string `json:"executeQueryIdsOnly,omitempty" yaml:"executeQueryIdsOnly,omitempty"`

	// IsTestOnly Set it to TRUE if you just want to test the report generation.
	// In this case the recipients (if set in report setup) will not be notified about this report at all. And only the user who generated it will receive a notification when report is ready to view. But apart from this the full report will be generated.
	IsTestOnly *bool `json:"isTestOnly,omitempty" yaml:"isTestOnly,omitempty"`

	// SkipNotifications If this is set to TRUE then recipients will not receive any notification from Keytiles when this Report Instance is created.
	// **IMPORTANT!** Use this with caution! This option was introduced mostly because of internal reasons under certain circumstances.
	SkipNotifications *bool `json:"skipNotifications,omitempty" yaml:"skipNotifications,omitempty"`
}

// GetContainerReportInstanceResponseClass defines model for GetContainerReportInstanceResponseClass.
type GetContainerReportInstanceResponseClass = externalRef2.ContainerResponseClass

// GetContainerReportSetupResponseClass defines model for GetContainerReportSetupResponseClass.
type GetContainerReportSetupResponseClass = externalRef2.ContainerResponseClass

// ListContainerReportInstancesResponseClass defines model for ListContainerReportInstancesResponseClass.
type ListContainerReportInstancesResponseClass = externalRef2.ContainerResponseClass

// ListContainerReportSetupsResponseClass defines model for ListContainerReportSetupsResponseClass.
type ListContainerReportSetupsResponseClass = externalRef2.ContainerResponseClass

// ReportInstance This is a specific instance of a ReportSetup which was generated at a certain point in time. Keytiles stores these reports for a while.
// A report instance consists of sections - each section is generated by a query.
type ReportInstance struct {
	// CreatedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
	CreatedAt *int32 `json:"createdAt,omitempty" yaml:"createdAt,omitempty"`

	// Description This is a longer description of the report - copied from the ReportSetup metaData when this instance was generated.
	Description *string `json:"description" yaml:"description"`

	// GeneratorUserId In case the report generation was triggered manually by someone then this field contains the ID of the user triggered the generation.
	GeneratorUserId *string `json:"generatorUserId" yaml:"generatorUserId"`

	// GeneratorUserNickname In case the report generation was triggered manually by someone then this field contains the Nickname of the user triggered the generation.
	GeneratorUserNickname *string `json:"generatorUserNickname" yaml:"generatorUserNickname"`

	// Id The unique ID of this report setup - UUID style
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// IsTestOnly Tells if this report instance is a result of a test generation only or not.
	IsTestOnly *bool `json:"isTestOnly,omitempty" yaml:"isTestOnly,omitempty"`

	// ParentReportSetupId The ID of the ReportSetup this instance belongs to.
	ParentReportSetupId *string                  `json:"parentReportSetupId,omitempty" yaml:"parentReportSetupId,omitempty"`
	Sections            *[]ReportInstanceSection `json:"sections,omitempty" yaml:"sections,omitempty"`

	// Title The title of the report - copied from the ReportSetup metaData when this instance was generated.
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// ReportInstanceSection defines model for ReportInstanceSection.
type ReportInstanceSection struct {
	DataTables *[]DataTable `json:"dataTables,omitempty" yaml:"dataTables,omitempty"`

	// Description This is a longer description of this section - copied from the ReportSetup appropriate Query part which produced this section when this instance was generated.
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`

	// Title The title of this section - copied from the ReportSetup appropriate Query part which produced this section when this instance was generated.
	Title *string `json:"title,omitempty" yaml:"title,omitempty"`
}

// ReportQuery A report can contain multiple queries. This object describes one query of those.
type ReportQuery struct {
	// Id The unique ID (within the report) of this query - UUID style. In concrete report instances this helps to identify the result of this query within the whole report.
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// IsDisabled It is possible to temporarily disable a query. This way you do not lose its setup, so you can re-enable it later again.
	IsDisabled *bool                 `json:"isDisabled,omitempty" yaml:"isDisabled,omitempty"`
	MetaData   externalRef0.MetaData `json:"metaData" yaml:"metaData"`

	// Parameters The parameters a query plugin needs depends on the plugin. These key-value pairs provide the setup how the query plugin will generate this part of the report.
	Parameters *ReportQuery_Parameters `json:"parameters,omitempty" yaml:"parameters,omitempty"`
	Plugin     ReportQueryPlugin       `json:"plugin" yaml:"plugin"`
}

// ReportQuery_Parameters The parameters a query plugin needs depends on the plugin. These key-value pairs provide the setup how the query plugin will generate this part of the report.
type ReportQuery_Parameters struct {
	// EventsIncluded Which event counts to include into the report? E.g. "pageview", or custom events e.g. "30 seconds passed". These will be the columns in your report. You can also construct formulas using the pure eventNames.
	EventsIncluded *[]string `json:"eventsIncluded,omitempty" yaml:"eventsIncluded,omitempty"`

	// GroupByTileGroupPathMaxDepth You can limit how deep you want the report to go down in the content structure. E.g. if you set it to 1 that means you get a break down only for first level.
	GroupByTileGroupPathMaxDepth *int `json:"groupByTileGroupPathMaxDepth,omitempty" yaml:"groupByTileGroupPathMaxDepth,omitempty"`

	// GroupByTileGroupPaths If set to TRUE then you get a break-down based on content structure (=tileGroupPath). Can not be used together with 'groupByTiles'!
	GroupByTileGroupPaths *bool `json:"groupByTileGroupPaths,omitempty" yaml:"groupByTileGroupPaths,omitempty"`

	// GroupByTiles If set to TRUE then you get a break-down on Tile level - otherwise just sum of the traffic of all Tiles.
	GroupByTiles *bool `json:"groupByTiles,omitempty" yaml:"groupByTiles,omitempty"`

	// GroupByTime If set to TRUE then you get a break-down in time interval. The interval is driven by your schedule.
	//  * Hourly schedule: you get 15 minutes break-down
	//  * Daily schedule: you get an hourly breakdown
	//  * Weekly schedule: you get a daily breakdown
	//  * Monthly schedule: you get a weekly breakdown
	GroupByTime *bool `json:"groupByTime,omitempty" yaml:"groupByTime,omitempty"`

	// Limit Optional param. How many rows you want to display maximum? Only makes sense if 'groupByTiles=true' or 'groupByTileGroupPaths=true'. Using the 'performanceDescendingOrder' basically you can see the top performing ones, or the worst performing ones - up to you.
	Limit                      *int  `json:"limit,omitempty" yaml:"limit,omitempty"`
	PerformanceDescendingOrder *bool `json:"performanceDescendingOrder,omitempty" yaml:"performanceDescendingOrder,omitempty"`

	// SortBy Sort the list based on these "eventsIncluded"
	SortBy *[]string `json:"sortBy,omitempty" yaml:"sortBy,omitempty"`

	// TileGroupPathMatchingOnly Data filter option. Comma separated list of matchers (see below) which returns counters only for those Tiles who's tileGroupPath is matching to one of the listed matchers. So if you list more values here then they are interpreted with an OR operator.
	//
	// note: if you have comma in your matcher (strange, but ok...) you can escape that with `\\` character!
	//
	// You can use the **'\*'** character to match any substring. But where and how you put this Asterisk character matters! Let us show you how through an example!
	// Let's assume you have articles and pages (Tiles) in the following content areas:
	//
	// * /auto * /tech * /tech/mobile-rumours * /tech/mobile * /tech/mobile/android * /tech/mobile/ios * /politics
	//
	// And now you execute queries with two different **tileGroupPathMatchingOnly** settings: 1. **"/tech/mobile\*"** and 1. **"/tech/mobile/\*"**
	// In the first query **"/tech/mobile\*"** would match for everything begins with "/tech/mobile" string. So this would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* Tiles but also would include *"/tech/mobile-rumours"* Tiles. Which are clearly two different areas right?
	//
	// But what if you want to really limit for Tiles under the *"/tech/mobile"* area?
	//
	// Well then you can use the second query value: **"/tech/mobile/\*"**. This would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* but would NOT include *"/tech/mobile-rumours"* anymore - as that is not a match anymore. But we are not done yet! Please note: this would also include Tiles under *"/tech/mobile/"* group itself. Because **"/\*"** means "everything which is under this group"
	TileGroupPathMatchingOnly *string `json:"tileGroupPathMatchingOnly,omitempty" yaml:"tileGroupPathMatchingOnly,omitempty"`

	// TileTypesOnly Data filter option. Comma separated list of tile types you want to limit the query for. If you list more values here then they are interpreted with an OR operator.
	//
	// IMPORTANT! You can not use this together with `tileTypeIsNot` parameter! You can only use this or that but not both.
	//
	// In the list you can either use: * The name of the type ('frontpage', 'page', 'article', ...), or * The numeric ID of the tile type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
	TileTypesOnly        *string                `json:"tileTypesOnly,omitempty" yaml:"tileTypesOnly,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReportQueryPlugin defines model for ReportQueryPlugin.
type ReportQueryPlugin string

// ReportRecipients This is an optional setup - controlls who will receive these reports.
//
// If not given at all then ALL Data Container users will get the report. Otherwise if given then Keytiles users who are matching to ANY of the given criteria will receive the report.
type ReportRecipients struct {
	// Roles Optional entry. All Data Container users who has ANY of the listed roles will receive this report.
	Roles *[]ReportRecipientsRoles `json:"roles,omitempty" yaml:"roles,omitempty"`

	// Users Optional entry. List of specific Keytiles users (email or ID) to send the reports to. The users who are listed here will get the reports for sure if
	//  * they are not disabled in Keytiles (can not log in)
	//  * they are not associated with the Data Container anyhow
	Users *[]string `json:"users,omitempty" yaml:"users,omitempty"`
}

// ReportRecipientsRoles defines model for ReportRecipientsRoles.
type ReportRecipientsRoles string

// ReportSetup defines model for ReportSetup.
type ReportSetup struct {
	// Id The unique ID of this report setup - UUID style
	Id       string                `json:"id" yaml:"id"`
	MetaData externalRef0.MetaData `json:"metaData" yaml:"metaData"`

	// Queries Queries of this report.
	Queries *[]ReportQuery `json:"queries" yaml:"queries"`

	// Recipients This is an optional setup - controlls who will receive these reports.
	//
	// If not given at all then ALL Data Container users will get the report. Otherwise if given then Keytiles users who are matching to ANY of the given criteria will receive the report.
	Recipients *ReportRecipients `json:"recipients" yaml:"recipients"`

	// ResourceVersion This is the resource version (which is automatically incremented by every change). When you do an update (PUT) you need to send it back! The server will check if it is matching with the resource version he has. If not then that means someone else already did an update in the meantime therefore your request can not be accepted - otherwise you may overwrite the changes someone did.
	ResourceVersion int `json:"resourceVersion" yaml:"resourceVersion"`

	// Schedule Describes a Schedule of something. As of now you have basically 4 types: hourly, daily, weekly and Monthly schedules.
	Schedule *externalRef1.Schedule `json:"schedule" yaml:"schedule"`
}

// ReportsEndpointErrorCodes defines model for ReportsEndpointErrorCodes.
type ReportsEndpointErrorCodes string

// ReportsEndpointLocalErrorCodes defines model for ReportsEndpointLocalErrorCodes.
type ReportsEndpointLocalErrorCodes string

// ReportInstanceId defines model for reportInstanceId.
type ReportInstanceId = string

// ReportSetupId defines model for reportSetupId.
type ReportSetupId = string

// PostV1ReportsContainersSetupRestContainerIdJSONRequestBody defines body for PostV1ReportsContainersSetupRestContainerId for application/json ContentType.
type PostV1ReportsContainersSetupRestContainerIdJSONRequestBody = ReportSetup

// PutV1ReportsContainersSetupRestContainerIdReportSetupIdJSONRequestBody defines body for PutV1ReportsContainersSetupRestContainerIdReportSetupId for application/json ContentType.
type PutV1ReportsContainersSetupRestContainerIdReportSetupIdJSONRequestBody = ReportSetup

// PostV1ReportsContainersSetupRestContainerIdReportSetupIdInstancesJSONRequestBody defines body for PostV1ReportsContainersSetupRestContainerIdReportSetupIdInstances for application/json ContentType.
type PostV1ReportsContainersSetupRestContainerIdReportSetupIdInstancesJSONRequestBody = GenerateReportRequestClass

// Getter for additional properties for ReportQuery_Parameters. Returns the specified
// element and whether it was found
func (a ReportQuery_Parameters) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ReportQuery_Parameters
func (a *ReportQuery_Parameters) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ReportQuery_Parameters to handle AdditionalProperties
func (a *ReportQuery_Parameters) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["eventsIncluded"]; found {
		err = json.Unmarshal(raw, &a.EventsIncluded)
		if err != nil {
			return fmt.Errorf("error reading 'eventsIncluded': %w", err)
		}
		delete(object, "eventsIncluded")
	}

	if raw, found := object["groupByTileGroupPathMaxDepth"]; found {
		err = json.Unmarshal(raw, &a.GroupByTileGroupPathMaxDepth)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTileGroupPathMaxDepth': %w", err)
		}
		delete(object, "groupByTileGroupPathMaxDepth")
	}

	if raw, found := object["groupByTileGroupPaths"]; found {
		err = json.Unmarshal(raw, &a.GroupByTileGroupPaths)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTileGroupPaths': %w", err)
		}
		delete(object, "groupByTileGroupPaths")
	}

	if raw, found := object["groupByTiles"]; found {
		err = json.Unmarshal(raw, &a.GroupByTiles)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTiles': %w", err)
		}
		delete(object, "groupByTiles")
	}

	if raw, found := object["groupByTime"]; found {
		err = json.Unmarshal(raw, &a.GroupByTime)
		if err != nil {
			return fmt.Errorf("error reading 'groupByTime': %w", err)
		}
		delete(object, "groupByTime")
	}

	if raw, found := object["limit"]; found {
		err = json.Unmarshal(raw, &a.Limit)
		if err != nil {
			return fmt.Errorf("error reading 'limit': %w", err)
		}
		delete(object, "limit")
	}

	if raw, found := object["performanceDescendingOrder"]; found {
		err = json.Unmarshal(raw, &a.PerformanceDescendingOrder)
		if err != nil {
			return fmt.Errorf("error reading 'performanceDescendingOrder': %w", err)
		}
		delete(object, "performanceDescendingOrder")
	}

	if raw, found := object["sortBy"]; found {
		err = json.Unmarshal(raw, &a.SortBy)
		if err != nil {
			return fmt.Errorf("error reading 'sortBy': %w", err)
		}
		delete(object, "sortBy")
	}

	if raw, found := object["tileGroupPathMatchingOnly"]; found {
		err = json.Unmarshal(raw, &a.TileGroupPathMatchingOnly)
		if err != nil {
			return fmt.Errorf("error reading 'tileGroupPathMatchingOnly': %w", err)
		}
		delete(object, "tileGroupPathMatchingOnly")
	}

	if raw, found := object["tileTypesOnly"]; found {
		err = json.Unmarshal(raw, &a.TileTypesOnly)
		if err != nil {
			return fmt.Errorf("error reading 'tileTypesOnly': %w", err)
		}
		delete(object, "tileTypesOnly")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ReportQuery_Parameters to handle AdditionalProperties
func (a ReportQuery_Parameters) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EventsIncluded != nil {
		object["eventsIncluded"], err = json.Marshal(a.EventsIncluded)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eventsIncluded': %w", err)
		}
	}

	if a.GroupByTileGroupPathMaxDepth != nil {
		object["groupByTileGroupPathMaxDepth"], err = json.Marshal(a.GroupByTileGroupPathMaxDepth)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTileGroupPathMaxDepth': %w", err)
		}
	}

	if a.GroupByTileGroupPaths != nil {
		object["groupByTileGroupPaths"], err = json.Marshal(a.GroupByTileGroupPaths)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTileGroupPaths': %w", err)
		}
	}

	if a.GroupByTiles != nil {
		object["groupByTiles"], err = json.Marshal(a.GroupByTiles)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTiles': %w", err)
		}
	}

	if a.GroupByTime != nil {
		object["groupByTime"], err = json.Marshal(a.GroupByTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupByTime': %w", err)
		}
	}

	if a.Limit != nil {
		object["limit"], err = json.Marshal(a.Limit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'limit': %w", err)
		}
	}

	if a.PerformanceDescendingOrder != nil {
		object["performanceDescendingOrder"], err = json.Marshal(a.PerformanceDescendingOrder)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'performanceDescendingOrder': %w", err)
		}
	}

	if a.SortBy != nil {
		object["sortBy"], err = json.Marshal(a.SortBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sortBy': %w", err)
		}
	}

	if a.TileGroupPathMatchingOnly != nil {
		object["tileGroupPathMatchingOnly"], err = json.Marshal(a.TileGroupPathMatchingOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tileGroupPathMatchingOnly': %w", err)
		}
	}

	if a.TileTypesOnly != nil {
		object["tileTypesOnly"], err = json.Marshal(a.TileTypesOnly)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tileTypesOnly': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsDataTableCell0 returns the union data inside the DataTableCell as a DataTableCell0
func (t DataTableCell) AsDataTableCell0() (DataTableCell0, error) {
	var body DataTableCell0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableCell0 overwrites any union data inside the DataTableCell as the provided DataTableCell0
func (t *DataTableCell) FromDataTableCell0(v DataTableCell0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsDataTableCell1 returns the union data inside the DataTableCell as a DataTableCell1
func (t DataTableCell) AsDataTableCell1() (DataTableCell1, error) {
	var body DataTableCell1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableCell1 overwrites any union data inside the DataTableCell as the provided DataTableCell1
func (t *DataTableCell) FromDataTableCell1(v DataTableCell1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DataTableCell) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataTableCell) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDataTableAxisColumn returns the union data inside the DataTableColumn as a DataTableAxisColumn
func (t DataTableColumn) AsDataTableAxisColumn() (DataTableAxisColumn, error) {
	var body DataTableAxisColumn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableAxisColumn overwrites any union data inside the DataTableColumn as the provided DataTableAxisColumn
func (t *DataTableColumn) FromDataTableAxisColumn(v DataTableAxisColumn) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsDataTableDataColumn returns the union data inside the DataTableColumn as a DataTableDataColumn
func (t DataTableColumn) AsDataTableDataColumn() (DataTableDataColumn, error) {
	var body DataTableDataColumn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataTableDataColumn overwrites any union data inside the DataTableColumn as the provided DataTableDataColumn
func (t *DataTableColumn) FromDataTableDataColumn(v DataTableDataColumn) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DataTableColumn) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataTableColumn) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
