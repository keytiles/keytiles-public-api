// Package kt_pubapi_gen_managementv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package kt_pubapi_gen_managementv1

import (
	"encoding/json"

	externalRef0 "github.com/keytiles/keytiles-public-api/gopkg/model/generated/common/types_v2"
)

const (
	OneTimeTokenAuthScopes = "OneTimeTokenAuth.Scopes"
	BasicAuthScopes        = "basicAuth.Scopes"
)

// Defines values for HitFaultType.
const (
	HitFaultTypeError   HitFaultType = "error"
	HitFaultTypeUnknown HitFaultType = "unknown"
	HitFaultTypeWarn    HitFaultType = "warn"
)

// Defines values for ManagementEndpointLocalErrorCodes.
const (
	ContainerDataAdminMissing     ManagementEndpointLocalErrorCodes = "containerData_admin_missing"
	ContainerDataFinanceMissing   ManagementEndpointLocalErrorCodes = "containerData_finance_missing"
	ContainerDataInvalid          ManagementEndpointLocalErrorCodes = "containerData_invalid"
	ContainerDataJsonDecodeFailed ManagementEndpointLocalErrorCodes = "containerData_jsonDecodeFailed"
	ContainerDataMissing          ManagementEndpointLocalErrorCodes = "containerData_missing"
	ContainerIdInvalid            ManagementEndpointLocalErrorCodes = "containerId_invalid"
	ContainerIdMissing            ManagementEndpointLocalErrorCodes = "containerId_missing"
	KeyInvalid                    ManagementEndpointLocalErrorCodes = "key_invalid"
	KeyMissing                    ManagementEndpointLocalErrorCodes = "key_missing"
	KeyValueDataInvalid           ManagementEndpointLocalErrorCodes = "keyValueData_invalid"
	PasswordDataInvalid           ManagementEndpointLocalErrorCodes = "passwordData_invalid"
	PasswordDataMissing           ManagementEndpointLocalErrorCodes = "passwordData_missing"
	ProtectedFieldChanged         ManagementEndpointLocalErrorCodes = "protectedField_changed"
	QueryRangeCorrected           ManagementEndpointLocalErrorCodes = "queryRange_corrected"
	QueryRangeFromCorrected       ManagementEndpointLocalErrorCodes = "queryRange_from_corrected"
	QueryRangeToCorrected         ManagementEndpointLocalErrorCodes = "queryRange_to_corrected"
	ReadonlyFieldChanged          ManagementEndpointLocalErrorCodes = "readonlyField_changed"
	RequiredFieldMissing          ManagementEndpointLocalErrorCodes = "requiredField_missing"
	UserDataEmailAlreadyTaken     ManagementEndpointLocalErrorCodes = "userData_email_alreadyTaken"
	UserDataEmailInvalid          ManagementEndpointLocalErrorCodes = "userData_email_invalid"
	UserDataInvalid               ManagementEndpointLocalErrorCodes = "userData_invalid"
	UserDataJsonDecodeFailed      ManagementEndpointLocalErrorCodes = "userData_jsonDecodeFailed"
	UserDataMissing               ManagementEndpointLocalErrorCodes = "userData_missing"
	UserDataNicknameInvalid       ManagementEndpointLocalErrorCodes = "userData_nickname_invalid"
	UserIdTermInvalid             ManagementEndpointLocalErrorCodes = "userIdTerm_invalid"
	UserIdTermMissing             ManagementEndpointLocalErrorCodes = "userIdTerm_missing"
)

// Defines values for ManagementEndpointProblemClassSeverity.
const (
	ManagementEndpointProblemClassSeverityError   ManagementEndpointProblemClassSeverity = "error"
	ManagementEndpointProblemClassSeverityWarning ManagementEndpointProblemClassSeverity = "warning"
)

// Defines values for UserContainerRoleClass.
const (
	UserContainerRoleClassAdmin UserContainerRoleClass = "admin"
	UserContainerRoleClassView  UserContainerRoleClass = "view"
)

// Defines values for UserContainerRoleClassV2.
const (
	UserContainerRoleClassV2Admin     UserContainerRoleClassV2 = "admin"
	UserContainerRoleClassV2Developer UserContainerRoleClassV2 = "developer"
	UserContainerRoleClassV2Finance   UserContainerRoleClassV2 = "finance"
	UserContainerRoleClassV2View      UserContainerRoleClassV2 = "view"
)

// ContainerClass defines model for ContainerClass.
type ContainerClass struct {
	// BusinessDomain Name of the Keytiles business domain this Container belongs to
	BusinessDomain *string `json:"businessDomain,omitempty"`

	// CreatedTimestamp When was this Container created? UNIX timestamp in UTC (seconds since Epoch)
	CreatedTimestamp *int32 `json:"createdTimestamp,omitempty"`

	// Id Randomly generated alpha-numeric unique id of the Container
	Id *string `json:"id,omitempty"`

	// IsEnabled If FALSE then tracking is disabled. Requires Keytiles Admin privilige to be able to modify this - read only otherwise
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name An informative name of your Container. Single line plain string so any linefeed or tab or other characters will lead to request failure.
	Name *string `json:"name,omitempty"`

	// Options Containers have settings - options is the object represents a collection of settings. For creating a container it is enough to start with the mandatory settings. They can be tweaked later via PUT.
	//
	// The following options are available:
	//  * **trackedDomains** : Array - Mandatory setting. List of domain names the tracking in this Container will accept as hit origin.
	//  * **lookBackTimeWindowSeconds** : Integer - Optional setting. When the real time UI is started this is the default "look back" time period for queries for your users
	//  * **visitSessionTimeoutSeconds** : Integer - Optional setting. Controls the visitSession length for your tracking. If not set then the system default value is used which is 20 minutes.
	//  * **preservedQueryParams** : Array - Optional setting. Normally Keytiles is cleaning the URLs the hits are coming from and as a part of this procedure all query parameters are also removed. Except the ones you list here in this array...
	//  * **trialEndsAt** : Integer - Optional setting. Gives the time in UNIX timestamp when the trial period of this container ends. If null that means the container is not in trial period. Note: this can not be modified directly!
	//  * **writeTrafficLimit** : Integer - Controlls the daily write traffic (number of inbound hits) limit. Note: this can not be modified directly!
	//  * **readTrafficLimit** : Integer - Controlls the daily read traffic limit. Note: this can not be modified directly!
	Options *ContainerOptionsClass `json:"options,omitempty"`

	// UserDetails Provides more details about Users who has access over this Container - but there are some restrictions.
	//
	// First of all - by default this list comes empty - you need to request this using the *includeUserDetails=true* query argument.
	//
	// Furthermore * If the resource is queried by a Container Admin or a Keytiles Admin then it contains full info about every users so no restrictions * But if the resource is queried by a normal member of the Container then limited the way it only exposes e-mail addresses of the Container Admins - others mail address is kept in secret
	UserDetails *[]ContainerUserDetails `json:"userDetails,omitempty"`

	// Users List of user IDs has access over this Container.
	//
	// This list is only visible if the resource is queried by a Container Admin or a Keytiles Admin. For all others this list comes empty as nobody else should see this information.
	Users *[]ContainerUserLink `json:"users,omitempty"`

	// Version This is the resource version (which is automatically incremented by every change). When you do an update (PUT) you need to send it back! The server will check if it is matching with the resource version he has. If not then that means someone else already did an update in the meantime therefore your request can not be accepted - otherwise you may overwrite the changes someone did.
	Version *int `json:"version,omitempty"`
}

// ContainerCreationClass Partial class of the ContainerClass - can be used in the REST POST endpoint during creating a container.
//
// Any registered User of Keytiles has the possibility to create a Container and establish tracking.
type ContainerCreationClass struct {
	// BusinessDomain Name of the Keytiles business domain this Container belongs to
	BusinessDomain *string `json:"businessDomain,omitempty"`

	// Name An informative name of your Container. Single line plain string so any linefeed or tab or other characters will lead to request failure.
	Name *string `json:"name,omitempty"`

	// Options Containers have settings - options is the object represents a collection of settings. For creating a container it is enough to start with the mandatory settings. They can be tweaked later via PUT.
	//
	// The following options are available:
	//  * **trackedDomains** : Array - Mandatory setting. List of domain names the tracking in this Container will accept as hit origin.
	//  * **lookBackTimeWindowSeconds** : Integer - Optional setting. When the real time UI is started this is the default "look back" time period for queries for your users
	//  * **visitSessionTimeoutSeconds** : Integer - Optional setting. Controls the visitSession length for your tracking. If not set then the system default value is used which is 20 minutes.
	//  * **preservedQueryParams** : Array - Optional setting. Normally Keytiles is cleaning the URLs the hits are coming from and as a part of this procedure all query parameters are also removed. Except the ones you list here in this array...
	//  * **trialEndsAt** : Integer - Optional setting. Gives the time in UNIX timestamp when the trial period of this container ends. If null that means the container is not in trial period. Note: this can not be modified directly!
	//  * **writeTrafficLimit** : Integer - Controlls the daily write traffic (number of inbound hits) limit. Note: this can not be modified directly!
	//  * **readTrafficLimit** : Integer - Controlls the daily read traffic limit. Note: this can not be modified directly!
	Options *ContainerOptionsClass `json:"options,omitempty"`
}

// ContainerOptionsClass Containers have settings - options is the object represents a collection of settings. For creating a container it is enough to start with the mandatory settings. They can be tweaked later via PUT.
//
// The following options are available:
//   - **trackedDomains** : Array - Mandatory setting. List of domain names the tracking in this Container will accept as hit origin.
//   - **lookBackTimeWindowSeconds** : Integer - Optional setting. When the real time UI is started this is the default "look back" time period for queries for your users
//   - **visitSessionTimeoutSeconds** : Integer - Optional setting. Controls the visitSession length for your tracking. If not set then the system default value is used which is 20 minutes.
//   - **preservedQueryParams** : Array - Optional setting. Normally Keytiles is cleaning the URLs the hits are coming from and as a part of this procedure all query parameters are also removed. Except the ones you list here in this array...
//   - **trialEndsAt** : Integer - Optional setting. Gives the time in UNIX timestamp when the trial period of this container ends. If null that means the container is not in trial period. Note: this can not be modified directly!
//   - **writeTrafficLimit** : Integer - Controlls the daily write traffic (number of inbound hits) limit. Note: this can not be modified directly!
//   - **readTrafficLimit** : Integer - Controlls the daily read traffic limit. Note: this can not be modified directly!
type ContainerOptionsClass map[string]map[string]interface{}

// ContainerUserDetails defines model for ContainerUserDetails.
type ContainerUserDetails struct {
	// Email The e-mail address of the user. BUT it is possible this field is masked out due to data protection rules and only returns 'secret' as value
	Email    *string `json:"email,omitempty"`
	Nickname *string `json:"nickname,omitempty"`

	// UserId The ID of the User
	UserId string `json:"userId"`
}

// ContainerUserLink defines model for ContainerUserLink.
type ContainerUserLink struct {
	// Role DEPRECATED! Older representation of the roles of this link affecting what the User can do with this Container - please use UserContainerRoleClassV2 instead
	// Deprecated:
	Role  *UserContainerRoleClass    `json:"role"`
	Roles []UserContainerRoleClassV2 `json:"roles"`

	// UserId The alpha-numeric unique id of the User
	UserId string `json:"userId"`
}

// HitFaultClass defines model for HitFaultClass.
type HitFaultClass struct {
	// ErrorCode The textual error code describes the problem. This is a machine readable error.
	ErrorCode *string `json:"errorCode,omitempty"`

	// ErrorDescription The human readable error description.
	ErrorDescription *string `json:"errorDescription"`

	// FaultTimestamp Timestamp of the fault - UNIX timestamp in UTC (seconds since Epoch)
	FaultTimestamp *int          `json:"faultTimestamp,omitempty"`
	FaultType      *HitFaultType `json:"faultType,omitempty"`

	// FaultUrl The URL associated with this fault. This comes from the 'tileUrl' attribute of the inbound hit.
	FaultUrl *string `json:"faultUrl"`

	// HitProducer The agent which sent this the hit in. This comes from the 'hitProducer' attribute of the inbound hit.
	HitProducer *string `json:"hitProducer"`

	// TileId The ID of the associated Tile. This comes from the 'tileId' attribute of the inbound hit.
	TileId *string `json:"tileId"`
}

// HitFaultReportResponse defines model for HitFaultReportResponse.
type HitFaultReportResponse struct {
	Container *externalRef0.ResponseContainerInfoClass `json:"container"`

	// DataFromTimestamp This response contains data starting by this UNIX timestamp in UTC (seconds since Epoch) - will be always rounded to at least minutes or even more (see section "Interval of your interest" above!)
	DataFromTimestamp int32 `json:"dataFromTimestamp"`

	// DataToTimestamp This response contains data until this UNIX timestamp in UTC (seconds since Epoch)
	DataToTimestamp int32            `json:"dataToTimestamp"`
	Faults          *[]HitFaultClass `json:"faults,omitempty"`

	// Problems List of errors/warnings
	Problems *[]externalRef0.ProblemBaseClass `json:"problems"`

	// ProcessingTookMillis Number of milliseconds the processing took on server side
	ProcessingTookMillis *int32 `json:"processingTookMillis"`

	// RequestReceivedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
	RequestReceivedAt int32 `json:"requestReceivedAt"`

	// RequestedFromTimestamp In the request you requested data starting by this UNIX timestamp in UTC (seconds since Epoch)
	RequestedFromTimestamp int32 `json:"requestedFromTimestamp"`

	// RequestedToTimestamp In the request you requested data until this UNIX timestamp in UTC (seconds since Epoch)
	RequestedToTimestamp int32 `json:"requestedToTimestamp"`
}

// HitFaultType defines model for HitFaultType.
type HitFaultType string

// MachineReadableManagementEndpointMessageResponseClass defines model for MachineReadableManagementEndpointMessageResponseClass.
type MachineReadableManagementEndpointMessageResponseClass struct {
	// Message The human readable message
	Message *string `json:"message,omitempty"`

	// Problems List of errors/warnings
	Problems *[]ManagementEndpointProblemClass `json:"problems,omitempty"`

	// ProcessingTookMillis Number of milliseconds the processing took on server side
	ProcessingTookMillis *int32 `json:"processingTookMillis"`

	// RequestReceivedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
	RequestReceivedAt int32 `json:"requestReceivedAt"`
}

// ManagementEndpointErrorCodes NOTE! Error codes is an Enum. Unfortunately in OpenApi (so far) there is no possibility to provide description for Enum values. But we have detailed description of each error codes! Please check the OpenApi file in our Github repo - you find them as comments for each Enum values!
type ManagementEndpointErrorCodes struct {
	union json.RawMessage
}

// ManagementEndpointLocalErrorCodes defines model for ManagementEndpointLocalErrorCodes.
type ManagementEndpointLocalErrorCodes string

// ManagementEndpointProblemClass defines model for ManagementEndpointProblemClass.
type ManagementEndpointProblemClass struct {
	ErrorCodes *[]ManagementEndpointErrorCodes `json:"errorCodes"`

	// Message The problem in human readable form
	Message string `json:"message"`

	// Place This info piece is most useful for 400 - "Bad Request" problems but can be meaningful of course in other scenarios too. It marks the place which has the problem.
	Place *externalRef0.ProblemPlaceEnum `json:"place"`

	// PlaceName If it makes sense it tells you which place was problematic. E.g. if a request parameter should be an Integer but you send in something wrong then "placeName" will tell you exactly which request parameter was wrong.
	PlaceName *string                                `json:"placeName"`
	Severity  ManagementEndpointProblemClassSeverity `json:"severity"`
}

// ManagementEndpointProblemClassSeverity defines model for ManagementEndpointProblemClass.Severity.
type ManagementEndpointProblemClassSeverity string

// ReferrerClassifierConfigClass defines model for ReferrerClassifierConfigClass.
type ReferrerClassifierConfigClass struct {
	// ClassifierClassName Name of the plugin responsible for doing the classification. We have 'SearchReferrer', 'SocialReferrer' and 'LinkReferrer' plugins (basically)
	ClassifierClassName *string `json:"classifierClassName,omitempty"`

	// DomainRegex Regex pattern matched against the domain name
	DomainRegex *string `json:"domainRegex,omitempty"`
	Name        *string `json:"name,omitempty"`

	// Options Options are plugin dependent key:value pairs - encoded into a string format.
	Options *string `json:"options,omitempty"`

	// PathRegex Regex pattern - if given then matched against the URI path part of the url
	PathRegex *string `json:"pathRegex,omitempty"`
}

// UserClass defines model for UserClass.
type UserClass struct {
	// Containers List of Containers this user has access to.
	//
	// This list is only visible if the resource is queried by the user himself or a Keytiles Admin. For all others this list comes empty as nobody else should see this information.
	Containers *[]UserContainerLink `json:"containers,omitempty"`

	// CreatedTimestamp When was this user created? UNIX timestamp in UTC (seconds since Epoch)
	CreatedTimestamp *int32 `json:"createdTimestamp,omitempty"`

	// Data Extra data of the user - key-value pairs. For internal use only so far - only visible to and manageable by Keytiles Admins.
	Data *map[string]string `json:"data"`

	// Email The validated e-mail address of the user (also this is his username used during login).
	//
	// Please note that it is possible this attribute is not returned but returns 'secret' as value for confidentiality reasons! This may depend on the credentials and/or the request parameters you use to query this resource!
	//
	// It is possible to change the e-mail address via a PUT request (so the login name basically) but depending on who is executing the request it may behave differently. If the user himself is initating the e-mail change then it will require a confirmation of the new e-mail address - a Token will be generated and sent out to the new e-mail address to complete the request.
	Email *string `json:"email,omitempty"`

	// Id Randomly generated alpha-numeric unique id of the user
	Id *string `json:"id,omitempty"`

	// IsEnabled If FALSE then user account is disabled. Requires Keytiles Admin privilige to be able to modify this - read only otherwise
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// IsKeytilesAdmin Tells if the user is a Keytiles Admin or not. Requires Keytiles Admin privilige to be able to modify this - read only otherwise
	IsKeytilesAdmin *bool `json:"isKeytilesAdmin,omitempty"`

	// LastLoginTimestamp When did this user log in recently? UNIX timestamp in UTC (seconds since Epoch)
	LastLoginTimestamp *int32 `json:"lastLoginTimestamp"`

	// Nickname The nickname of the user. This will appear for other users and also the system will use this in notifications. But of course you do not need to use your real name...
	Nickname *string `json:"nickname,omitempty"`

	// Password The password of the user used only for updating it but never shown.
	Password *string `json:"password,omitempty"`

	// Version This is the resource version (which is automatically incremented by every change). When you do an update (PUT) you need to send it back! The server will check if it is matching with the resource version he has. If not then that means someone else already did an update in the meantime therefore your request can not be accepted - otherwise you may overwrite the changes someone did.
	Version *int `json:"version,omitempty"`
}

// UserContainerLink defines model for UserContainerLink.
type UserContainerLink struct {
	// ContainerId The alpha-numeric unique id of the Container
	ContainerId string `json:"containerId"`

	// Role DEPRECATED! Older representation of the roles of this link affecting what the User can do with this Container - please use UserContainerRoleClassV2 instead
	// Deprecated:
	Role  *UserContainerRoleClass    `json:"role"`
	Roles []UserContainerRoleClassV2 `json:"roles"`
}

// UserContainerRoleClass DEPRECATED! Older representation of the roles of this link affecting what the User can do with this Container - please use UserContainerRoleClassV2 instead
type UserContainerRoleClass string

// UserContainerRoleClassV2 Newer definition of the roles of this link affecting what the User can do with this Container
type UserContainerRoleClassV2 string

// UserCreationClass defines model for UserCreationClass.
type UserCreationClass struct {
	// Email The desired e-mail address of the user (also this will be the username used during login later)
	Email *string `json:"email,omitempty"`

	// Nickname The nickname of the user. This will appear for other users and also the system will use this in notifications. But of course you do not need to use your real name... Single line plain string so any linefeed or tab or other characters will lead to request failure.
	Nickname *string `json:"nickname,omitempty"`

	// Password The password to set after successful e-mail validation flow. Single line plain string so any linefeed or tab or other characters will lead to request failure.
	Password *string `json:"password,omitempty"`
}

// IncludeUserDetails defines model for includeUserDetails.
type IncludeUserDetails = bool

// UserIdTerm defines model for userIdTerm.
type UserIdTerm = string

// GetV1ManagementContainersReportsContainerIdHitfaultParams defines parameters for GetV1ManagementContainersReportsContainerIdHitfault.
type GetV1ManagementContainersReportsContainerIdHitfaultParams struct {
	// FromTimestamp Defines the beginning of the query range - you are interested in data which time is >= than this timestamp.
	//
	// Format is mixed. It can be
	//  * a UNIX timestamp in UTC (seconds since Epoch) e.g.: `1657261221` - means 2022-07-08 6:20:21 GMT
	//    (note: server and client clock might be different! see: /v2/system/clock endpoint to query server time)
	//  * a relative time spec compared to current time in form of 'now[-X<m|h|d>]' where 'm' means minutes, 'h' means hours and 'd' means days,
	//    e.g.: `now-10m` means 10 minutes earlier compared to current time,
	//    `now-2h` means 2 hours earlier and so on
	//
	// This must point to the past!   (note: server validates according to his own clock!)
	FromTimestamp externalRef0.FromTimestamp `form:"fromTimestamp" json:"fromTimestamp"`

	// ToTimestamp Defines the end of the query range - you are interested in data which time is <= than this timestamp.
	//
	// **Default value:** the current timestamp, so 'now' if you do not specify this parameter.
	//
	// Format is mixed. It can be
	//  * a UNIX timestamp in UTC (seconds since Epoch) e.g.: `1657261221` - means 2022-07-08 6:20:21 GMT
	//    (note: server and client clock might be different! see: /v2/system/clock endpoint to query server time)
	//  * a relative time spec compared to current time in form of 'now[-X<m|h|d>]' where 'm' means minutes, 'h' means hours and 'd' means days,
	//    e.g.: `now-10m` means 10 minutes earlier compared to current time,
	//    `now-2h` means 2 hours earlier and so on
	//
	// Can not point to the future!   (note: server validates according to his own clock!)
	ToTimestamp *externalRef0.ToTimestamp `form:"toTimestamp,omitempty" json:"toTimestamp,omitempty"`

	// TileIdsOnly You can provide a comma separated list of tileIds. If given then only those Faults are returned whos related Tile is matching to the list.
	TileIdsOnly *string `form:"tileIdsOnly,omitempty" json:"tileIdsOnly,omitempty"`

	// Limit You can limit how many Faults are returned in the response maximum. Please note that since there is no time order guarantee in this request - so if you limit the number of items they might come in random order from the full time query range.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// FaultUrlMatchingOnly Faults are associated with URLs where they happened. Here you can provide a list of comma separated URL matcher strings. If you do so then only those Faults are returned whos associated URL is matching any of the matchers.
	//
	// For example:
	//  * '*/politics/*' will return only those Faults where "/politics/" as substring is found in the URL
	//  * '*/politics/*, */tags/*/visit*' will return Faults where either "/politics/" is in the URL or the URL is has the "/tags/<anything here>/visit" substring in it
	FaultUrlMatchingOnly *string `form:"faultUrlMatchingOnly,omitempty" json:"faultUrlMatchingOnly,omitempty"`
}

// GetV1ManagementContainersRestParams defines parameters for GetV1ManagementContainersRest.
type GetV1ManagementContainersRestParams struct {
	// ContainerIds A comma separated list of Container IDs to query.
	//
	// Please note! The method returns only Containers the user has at least 'view' permission to. So it is possible that in the response you do not get back all the Containers you requested if this rule is not fulfilled.
	ContainerIds *string `form:"containerIds,omitempty" json:"containerIds,omitempty"`

	// IncludeUserDetails Whether to include the *userDetails* list into the Container resource or not - default is: FALSE. Valid values are natural values encoding a boolean so e.g. "true" or "false" or 0 or 1 etc.
	IncludeUserDetails *IncludeUserDetails `form:"includeUserDetails,omitempty" json:"includeUserDetails,omitempty"`
}

// GetV1ManagementContainersRestContainerIdParams defines parameters for GetV1ManagementContainersRestContainerId.
type GetV1ManagementContainersRestContainerIdParams struct {
	// IncludeUserDetails Whether to include the *userDetails* list into the Container resource or not - default is: FALSE. Valid values are natural values encoding a boolean so e.g. "true" or "false" or 0 or 1 etc.
	IncludeUserDetails *IncludeUserDetails `form:"includeUserDetails,omitempty" json:"includeUserDetails,omitempty"`
}

// PostV1ManagementUsersActionsUserIdTermPasswordCheckTextBody defines parameters for PostV1ManagementUsersActionsUserIdTermPasswordCheck.
type PostV1ManagementUsersActionsUserIdTermPasswordCheckTextBody = string

// PutV1ManagementUsersRestUserIdTermPasswordTextBody defines parameters for PutV1ManagementUsersRestUserIdTermPassword.
type PutV1ManagementUsersRestUserIdTermPasswordTextBody = string

// PostV1ManagementContainersRestJSONRequestBody defines body for PostV1ManagementContainersRest for application/json ContentType.
type PostV1ManagementContainersRestJSONRequestBody = ContainerCreationClass

// PutV1ManagementContainersRestContainerIdJSONRequestBody defines body for PutV1ManagementContainersRestContainerId for application/json ContentType.
type PutV1ManagementContainersRestContainerIdJSONRequestBody = ContainerClass

// PostV1ManagementUsersActionsUserIdTermPasswordCheckTextRequestBody defines body for PostV1ManagementUsersActionsUserIdTermPasswordCheck for text/plain ContentType.
type PostV1ManagementUsersActionsUserIdTermPasswordCheckTextRequestBody = PostV1ManagementUsersActionsUserIdTermPasswordCheckTextBody

// PostV1ManagementUsersRestJSONRequestBody defines body for PostV1ManagementUsersRest for application/json ContentType.
type PostV1ManagementUsersRestJSONRequestBody = UserCreationClass

// PutV1ManagementUsersRestUserIdTermJSONRequestBody defines body for PutV1ManagementUsersRestUserIdTerm for application/json ContentType.
type PutV1ManagementUsersRestUserIdTermJSONRequestBody = UserClass

// PutV1ManagementUsersRestUserIdTermPasswordTextRequestBody defines body for PutV1ManagementUsersRestUserIdTermPassword for text/plain ContentType.
type PutV1ManagementUsersRestUserIdTermPasswordTextRequestBody = PutV1ManagementUsersRestUserIdTermPasswordTextBody

// AsManagementEndpointLocalErrorCodes returns the union data inside the ManagementEndpointErrorCodes as a ManagementEndpointLocalErrorCodes
func (t ManagementEndpointErrorCodes) AsManagementEndpointLocalErrorCodes() (ManagementEndpointLocalErrorCodes, error) {
	var body ManagementEndpointLocalErrorCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromManagementEndpointLocalErrorCodes overwrites any union data inside the ManagementEndpointErrorCodes as the provided ManagementEndpointLocalErrorCodes
func (t *ManagementEndpointErrorCodes) FromManagementEndpointLocalErrorCodes(v ManagementEndpointLocalErrorCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsExternalRef0CommonErrorCodes returns the union data inside the ManagementEndpointErrorCodes as a externalRef0.CommonErrorCodes
func (t ManagementEndpointErrorCodes) AsExternalRef0CommonErrorCodes() (externalRef0.CommonErrorCodes, error) {
	var body externalRef0.CommonErrorCodes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalRef0CommonErrorCodes overwrites any union data inside the ManagementEndpointErrorCodes as the provided externalRef0.CommonErrorCodes
func (t *ManagementEndpointErrorCodes) FromExternalRef0CommonErrorCodes(v externalRef0.CommonErrorCodes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t ManagementEndpointErrorCodes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ManagementEndpointErrorCodes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
