// Package kt_pubapi_gen_common_schedulev1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package kt_pubapi_gen_common_schedulev1

import (
	"encoding/json"
)

// Defines values for MonthlyScheduleDayName.
const (
	FirstDay MonthlyScheduleDayName = "firstDay"
	FirstFri MonthlyScheduleDayName = "firstFri"
	FirstMon MonthlyScheduleDayName = "firstMon"
	FirstSat MonthlyScheduleDayName = "firstSat"
	FirstSun MonthlyScheduleDayName = "firstSun"
	FirstThu MonthlyScheduleDayName = "firstThu"
	FirstTue MonthlyScheduleDayName = "firstTue"
	FirstWed MonthlyScheduleDayName = "firstWed"
	LastDay  MonthlyScheduleDayName = "lastDay"
)

// Defines values for ScheduleType.
const (
	Daily   ScheduleType = "daily"
	Hourly  ScheduleType = "hourly"
	Monthly ScheduleType = "monthly"
	Weekly  ScheduleType = "weekly"
)

// Defines values for ScheduleDayName.
const (
	Fri ScheduleDayName = "Fri"
	Mon ScheduleDayName = "Mon"
	Sat ScheduleDayName = "Sat"
	Sun ScheduleDayName = "Sun"
	Thu ScheduleDayName = "Thu"
	Tue ScheduleDayName = "Tue"
	Wed ScheduleDayName = "Wed"
)

// DailyScheduleSetup Encodes scheduling tailored for daily execution.
type DailyScheduleSetup struct {
	// DayNames Optional setting. If given then scheduling will happen only on these days. This is a day mask basically.
	DayNames *[]ScheduleDayName `json:"dayNames" yaml:"dayNames"`

	// TriggerTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
	TriggerTime string `json:"triggerTime" yaml:"triggerTime"`
}

// HourlyScheduleSetup Encodes scheduling tailored for hourly execution.
type HourlyScheduleSetup struct {
	// DayNames Optional setting. If given then scheduling will happen only on these days. This is a day mask basically.
	DayNames *[]ScheduleDayName `json:"dayNames" yaml:"dayNames"`

	// FirstTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution first? From this time the action is shcheduled every hour.
	//
	// For example if you set it to "09:15" then first execution happens at 09:15, the next one at 10:15 then 11:15 and so on.
	FirstTime string `json:"firstTime" yaml:"firstTime"`

	// UntilTime Optional setting. This is an "HH:MM" formatted time descriptor. Means: within a day triggering will happen only if the current time is <= than this time.
	//
	// For example, if `firstTime="09:15"` then actually the last execution of the action will happen at "17:15".
	//
	// In case not given then scheduling will happen within the day every hour starting from `firstTime`.
	UntilTime *string `json:"untilTime" yaml:"untilTime"`
}

// MonthlyScheduleDayName Name of days we can use in a monthly setup.
//   - `firstDay` - action is triggered on first day of the month
//   - `lastDay` - action is triggered on last day of the month
//   - weekday like `firstMon` etc - action is triggered on the first Monday of the month
type MonthlyScheduleDayName string

// MonthlyScheduleSetup Encodes scheduling tailored for monthly execution.
type MonthlyScheduleSetup struct {
	// DayName Name of days we can use in a monthly setup.
	//   * `firstDay` - action is triggered on first day of the month
	//   * `lastDay` - action is triggered on last day of the month
	//   * weekday like `firstMon` etc - action is triggered on the first Monday of the month
	DayName *MonthlyScheduleDayName `json:"dayName" yaml:"dayName"`

	// TriggerTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
	TriggerTime string `json:"triggerTime" yaml:"triggerTime"`
}

// Schedule Describes a Schedule of something. As of now you have basically 4 types: hourly, daily, weekly and Monthly schedules.
type Schedule struct {
	// MajorVersion The major version of the Schedule schema which was used when this object was created. This helps to evolve Schedules over time.
	MajorVersion int            `json:"majorVersion" yaml:"majorVersion"`
	Setup        Schedule_Setup `json:"setup" yaml:"setup"`

	// Type Describes which type of schedule is this?
	Type ScheduleType `json:"type" yaml:"type"`

	// TzOffset Encodes the time zone offset from UTC - all things like time and even the days(!) are given using this offset
	TzOffset int `json:"tzOffset" yaml:"tzOffset"`
}

// Schedule_Setup defines model for Schedule.Setup.
type Schedule_Setup struct {
	union json.RawMessage
}

// ScheduleType Describes which type of schedule is this?
type ScheduleType string

// ScheduleDayName Name of the days we use in day masks.
type ScheduleDayName string

// WeeklyScheduleSetup Encodes scheduling tailored for weekly execution.
type WeeklyScheduleSetup struct {
	// DayName Name of the days we use in day masks.
	DayName *ScheduleDayName `json:"dayName" yaml:"dayName"`

	// TriggerTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
	TriggerTime string `json:"triggerTime" yaml:"triggerTime"`
}

// AsHourlyScheduleSetup returns the union data inside the Schedule_Setup as a HourlyScheduleSetup
func (t Schedule_Setup) AsHourlyScheduleSetup() (HourlyScheduleSetup, error) {
	var body HourlyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHourlyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided HourlyScheduleSetup
func (t *Schedule_Setup) FromHourlyScheduleSetup(v HourlyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsDailyScheduleSetup returns the union data inside the Schedule_Setup as a DailyScheduleSetup
func (t Schedule_Setup) AsDailyScheduleSetup() (DailyScheduleSetup, error) {
	var body DailyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDailyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided DailyScheduleSetup
func (t *Schedule_Setup) FromDailyScheduleSetup(v DailyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsWeeklyScheduleSetup returns the union data inside the Schedule_Setup as a WeeklyScheduleSetup
func (t Schedule_Setup) AsWeeklyScheduleSetup() (WeeklyScheduleSetup, error) {
	var body WeeklyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWeeklyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided WeeklyScheduleSetup
func (t *Schedule_Setup) FromWeeklyScheduleSetup(v WeeklyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsMonthlyScheduleSetup returns the union data inside the Schedule_Setup as a MonthlyScheduleSetup
func (t Schedule_Setup) AsMonthlyScheduleSetup() (MonthlyScheduleSetup, error) {
	var body MonthlyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonthlyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided MonthlyScheduleSetup
func (t *Schedule_Setup) FromMonthlyScheduleSetup(v MonthlyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Schedule_Setup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Schedule_Setup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
