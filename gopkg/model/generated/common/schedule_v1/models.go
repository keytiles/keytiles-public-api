// Package kt_pubapi_gen_common_schedulev1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package kt_pubapi_gen_common_schedulev1

import (
	"encoding/json"
)

// Defines values for MonthlyScheduleSetupDayName1.
const (
	FirstDay MonthlyScheduleSetupDayName1 = "firstDay"
	LastDay  MonthlyScheduleSetupDayName1 = "lastDay"
)

// Defines values for ScheduleType.
const (
	Daily   ScheduleType = "daily"
	Hourly  ScheduleType = "hourly"
	Monthly ScheduleType = "monthly"
	Weekly  ScheduleType = "weekly"
)

// Defines values for ScheduleDayName.
const (
	Fri ScheduleDayName = "Fri"
	Mon ScheduleDayName = "Mon"
	Sat ScheduleDayName = "Sat"
	Sun ScheduleDayName = "Sun"
	Thu ScheduleDayName = "Thu"
	Tue ScheduleDayName = "Tue"
	Wed ScheduleDayName = "Wed"
)

// DailyScheduleSetup Encodes scheduling tailored for daily execution.
type DailyScheduleSetup struct {
	// DayNames Optional setting. If given then scheduling will happen only on these days. This is a day mask basically.
	DayNames *[]ScheduleDayName `json:"dayNames,omitempty"`

	// TriggerTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
	TriggerTime string `json:"triggerTime"`
}

// HourlyScheduleSetup Encodes scheduling tailored for hourly execution.
type HourlyScheduleSetup struct {
	// DayNames Optional setting. If given then scheduling will happen only on these days. This is a day mask basically.
	DayNames *[]ScheduleDayName `json:"dayNames,omitempty"`

	// FirstTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution first? From this time the action is shcheduled every hour.
	//
	// For example if you set it to "09:15" then first execution happens at 09:15, the next one at 10:15 then 11:15 and so on.
	FirstTime string `json:"firstTime"`

	// UntilTime Optional setting. This is an "HH:MM" formatted time descriptor. Means: within a day triggering will happen only if the current time is <= than this time.
	//
	// For example, if `firstTime="09:15"` then actually the last execution of the action will happen at "17:15".
	//
	// In case not given then scheduling will happen within the day every hour starting from `firstTime`.
	UntilTime *string `json:"untilTime,omitempty"`
}

// MonthlyScheduleSetup Encodes scheduling tailored for monthly execution.
type MonthlyScheduleSetup struct {
	// DayName Optional element. To pick up the day when the report is triggered you have a few options. If not given then simply it will be 'firstDay'.
	DayName *MonthlyScheduleSetup_DayName `json:"dayName,omitempty"`

	// TriggerTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
	TriggerTime string `json:"triggerTime"`
}

// MonthlyScheduleSetupDayName1 defines model for MonthlyScheduleSetup.DayName.1.
type MonthlyScheduleSetupDayName1 string

// MonthlyScheduleSetup_DayName Optional element. To pick up the day when the report is triggered you have a few options. If not given then simply it will be 'firstDay'.
type MonthlyScheduleSetup_DayName struct {
	union json.RawMessage
}

// Schedule Describes a Schedule of something. As of now you have basically 4 types: hourly, daily, weekly and Monthly schedules.
type Schedule struct {
	// MajorVersion The major version of the Schedule schema which was used when this object was created. This helps to evolve Schedules over time.
	MajorVersion int            `json:"majorVersion"`
	Setup        Schedule_Setup `json:"setup"`

	// Type Describes which type of schedule is this?
	Type ScheduleType `json:"type"`
}

// Schedule_Setup defines model for Schedule.Setup.
type Schedule_Setup struct {
	union json.RawMessage
}

// ScheduleType Describes which type of schedule is this?
type ScheduleType string

// ScheduleDayName Name of the days we use in day masks.
type ScheduleDayName string

// WeeklyScheduleSetup Encodes scheduling tailored for weekly execution.
type WeeklyScheduleSetup struct {
	// DayName Name of the days we use in day masks.
	DayName *ScheduleDayName `json:"dayName,omitempty"`

	// TriggerTime Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
	TriggerTime string `json:"triggerTime"`
}

// AsScheduleDayName returns the union data inside the MonthlyScheduleSetup_DayName as a ScheduleDayName
func (t MonthlyScheduleSetup_DayName) AsScheduleDayName() (ScheduleDayName, error) {
	var body ScheduleDayName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScheduleDayName overwrites any union data inside the MonthlyScheduleSetup_DayName as the provided ScheduleDayName
func (t *MonthlyScheduleSetup_DayName) FromScheduleDayName(v ScheduleDayName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsMonthlyScheduleSetupDayName1 returns the union data inside the MonthlyScheduleSetup_DayName as a MonthlyScheduleSetupDayName1
func (t MonthlyScheduleSetup_DayName) AsMonthlyScheduleSetupDayName1() (MonthlyScheduleSetupDayName1, error) {
	var body MonthlyScheduleSetupDayName1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonthlyScheduleSetupDayName1 overwrites any union data inside the MonthlyScheduleSetup_DayName as the provided MonthlyScheduleSetupDayName1
func (t *MonthlyScheduleSetup_DayName) FromMonthlyScheduleSetupDayName1(v MonthlyScheduleSetupDayName1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t MonthlyScheduleSetup_DayName) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MonthlyScheduleSetup_DayName) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHourlyScheduleSetup returns the union data inside the Schedule_Setup as a HourlyScheduleSetup
func (t Schedule_Setup) AsHourlyScheduleSetup() (HourlyScheduleSetup, error) {
	var body HourlyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHourlyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided HourlyScheduleSetup
func (t *Schedule_Setup) FromHourlyScheduleSetup(v HourlyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsDailyScheduleSetup returns the union data inside the Schedule_Setup as a DailyScheduleSetup
func (t Schedule_Setup) AsDailyScheduleSetup() (DailyScheduleSetup, error) {
	var body DailyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDailyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided DailyScheduleSetup
func (t *Schedule_Setup) FromDailyScheduleSetup(v DailyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsWeeklyScheduleSetup returns the union data inside the Schedule_Setup as a WeeklyScheduleSetup
func (t Schedule_Setup) AsWeeklyScheduleSetup() (WeeklyScheduleSetup, error) {
	var body WeeklyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWeeklyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided WeeklyScheduleSetup
func (t *Schedule_Setup) FromWeeklyScheduleSetup(v WeeklyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// AsMonthlyScheduleSetup returns the union data inside the Schedule_Setup as a MonthlyScheduleSetup
func (t Schedule_Setup) AsMonthlyScheduleSetup() (MonthlyScheduleSetup, error) {
	var body MonthlyScheduleSetup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMonthlyScheduleSetup overwrites any union data inside the Schedule_Setup as the provided MonthlyScheduleSetup
func (t *Schedule_Setup) FromMonthlyScheduleSetup(v MonthlyScheduleSetup) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t Schedule_Setup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Schedule_Setup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
