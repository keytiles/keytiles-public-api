// Package kt_pubapi_gen_common_typesv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package kt_pubapi_gen_common_typesv1

// Defines values for MessageResponseClassStatus.
const (
	Failed  MessageResponseClassStatus = "failed"
	Ok      MessageResponseClassStatus = "ok"
	Warning MessageResponseClassStatus = "warning"
)

// Defines values for TileTypeEnum.
const (
	Article   TileTypeEnum = "article"
	Frontpage TileTypeEnum = "frontpage"
	Page      TileTypeEnum = "page"
)

// BaseResponseClass defines model for BaseResponseClass.
type BaseResponseClass struct {
	// Messages List of human readable messages might help you understand better why you not got back what you requested (e.g. if returned a different interval) and fine tune your queries
	Messages *[]string `json:"messages,omitempty" yaml:"messages,omitempty"`

	// ProcessingTookMillis Number of milliseconds the processing took on server side
	ProcessingTookMillis *int32 `json:"processingTookMillis,omitempty" yaml:"processingTookMillis,omitempty"`

	// RequestReceivedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
	RequestReceivedAt *int32 `json:"requestReceivedAt,omitempty" yaml:"requestReceivedAt,omitempty"`
}

// IntervalBasedResponseClass defines model for IntervalBasedResponseClass.
type IntervalBasedResponseClass struct {
	Container *ResponseContainerInfoClass `json:"container,omitempty" yaml:"container,omitempty"`

	// DataFromTimestamp This response contains data starting by this UNIX timestamp in UTC (seconds since Epoch) - will be always rounded to at least minutes or even more (see section "Interval of your interest" above!)
	DataFromTimestamp *int32 `json:"dataFromTimestamp,omitempty" yaml:"dataFromTimestamp,omitempty"`

	// DataToTimestamp This response contains data until this UNIX timestamp in UTC (seconds since Epoch)
	DataToTimestamp *int32 `json:"dataToTimestamp,omitempty" yaml:"dataToTimestamp,omitempty"`

	// Messages List of human readable messages might help you understand better why you not got back what you requested (e.g. if returned a different interval) and fine tune your queries
	Messages *[]string `json:"messages,omitempty" yaml:"messages,omitempty"`

	// ProcessingTookMillis Number of milliseconds the processing took on server side
	ProcessingTookMillis *int32 `json:"processingTookMillis,omitempty" yaml:"processingTookMillis,omitempty"`

	// RequestReceivedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
	RequestReceivedAt *int32 `json:"requestReceivedAt,omitempty" yaml:"requestReceivedAt,omitempty"`

	// RequestedFromTimestamp In the request you requested data starting by this UNIX timestamp in UTC (seconds since Epoch)
	RequestedFromTimestamp *int32 `json:"requestedFromTimestamp,omitempty" yaml:"requestedFromTimestamp,omitempty"`

	// RequestedToTimestamp In the request you requested data until this UNIX timestamp in UTC (seconds since Epoch)
	RequestedToTimestamp *int32 `json:"requestedToTimestamp,omitempty" yaml:"requestedToTimestamp,omitempty"`
}

// IntervalBasedResponseWithResolutionClass defines model for IntervalBasedResponseWithResolutionClass.
type IntervalBasedResponseWithResolutionClass struct {
	Container *ResponseContainerInfoClass `json:"container,omitempty" yaml:"container,omitempty"`

	// DataFromTimestamp This response contains data starting by this UNIX timestamp in UTC (seconds since Epoch) - will be always rounded to at least minutes or even more (see section "Interval of your interest" above!)
	DataFromTimestamp *int32 `json:"dataFromTimestamp,omitempty" yaml:"dataFromTimestamp,omitempty"`

	// DataToTimestamp This response contains data until this UNIX timestamp in UTC (seconds since Epoch)
	DataToTimestamp *int32 `json:"dataToTimestamp,omitempty" yaml:"dataToTimestamp,omitempty"`

	// Messages List of human readable messages might help you understand better why you not got back what you requested (e.g. if returned a different interval) and fine tune your queries
	Messages *[]string `json:"messages,omitempty" yaml:"messages,omitempty"`

	// ProcessingTookMillis Number of milliseconds the processing took on server side
	ProcessingTookMillis *int32 `json:"processingTookMillis,omitempty" yaml:"processingTookMillis,omitempty"`

	// RequestReceivedAt The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
	RequestReceivedAt *int32 `json:"requestReceivedAt,omitempty" yaml:"requestReceivedAt,omitempty"`

	// RequestedFromTimestamp In the request you requested data starting by this UNIX timestamp in UTC (seconds since Epoch)
	RequestedFromTimestamp *int32 `json:"requestedFromTimestamp,omitempty" yaml:"requestedFromTimestamp,omitempty"`

	// RequestedToTimestamp In the request you requested data until this UNIX timestamp in UTC (seconds since Epoch)
	RequestedToTimestamp *int32 `json:"requestedToTimestamp,omitempty" yaml:"requestedToTimestamp,omitempty"`

	// ResolutionIntervals The data returned has a break down into these intervals. Please read generic "Requesting a break down of stats within the interval" section above to understand it better!
	ResolutionIntervals *[]IntervalClass `json:"resolutionIntervals,omitempty" yaml:"resolutionIntervals,omitempty"`
}

// IntervalClass defines model for IntervalClass.
type IntervalClass struct {
	// Id Basically the index of the interval - within the returned data interval
	Id *int `json:"id,omitempty" yaml:"id,omitempty"`

	// Length Length of this interval in seconds
	Length *int32 `json:"length,omitempty" yaml:"length,omitempty"`

	// Starts Beginning of interval in seconds relative to the returned global data time-frame. If you want to know absolute timestamp then add this to /dataFromTimestamp attribute value
	Starts *int32 `json:"starts,omitempty" yaml:"starts,omitempty"`
}

// MessageResponseClass defines model for MessageResponseClass.
type MessageResponseClass struct {
	// Message Human readable error/success/result message
	Message *string `json:"message,omitempty" yaml:"message,omitempty"`

	// Status Textual description of the status
	Status *MessageResponseClassStatus `json:"status,omitempty" yaml:"status,omitempty"`
}

// MessageResponseClassStatus Textual description of the status
type MessageResponseClassStatus string

// ResponseContainerInfoClass defines model for ResponseContainerInfoClass.
type ResponseContainerInfoClass struct {
	// Id The ID of the container - this is typically a UUID like value
	Id *string `json:"id,omitempty" yaml:"id,omitempty"`

	// Name The name of the container
	Name *string `json:"name,omitempty" yaml:"name,omitempty"`
}

// TileTypeEnum Possible values for type of tiles
type TileTypeEnum string
