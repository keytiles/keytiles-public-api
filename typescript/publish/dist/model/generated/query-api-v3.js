/**
 * Generated by orval v7.10.0 ðŸº
 * Do not edit manually.
 * Keytiles Statistics query API
 *
# Disclaimer
**PLEASE NOTE! This is an early release of v2 API which is currently in Beta test phase!**   This means things can still change!
 
# Overview
This API provides endpoints to query statistics data stored by Keytiles service.
  
To specify / fine tune queries you use query parameters which we can group into a few groups.
  
### Query range
To make queries you need to specify the query time range. To do that you can use the:

 * **fromTimestamp** - Start of your query range inclusive (>=). This is a UNIX timstamp (seconds since Epoch, UTC).
 
 * **toTimestamp** - End of your query range inclusive (<=). This is either a UNIX timestamp or "now" as a string meaning current time

### Filtering
Optionally you can filter the data due to several criteria.
  
For example if you are interested in only "view" event types then you can use the **eventTypesOnly=view** filter parameter.   Or you can also filter for **tileIdsOnly=tileId1,tileId2** if you are just interested in specific tiles stat data.
  
For complete list please check the query parameters of the endpoints! Look for "***Only**" parameters!
### Details - your interest
By default only the most relevant details are returned however in several endpoints you can definitely ask for more. You can do this using the **interest** query parameter.
  
For example if you query the event counts for Tiles what you will get back by default is only the total number of events registered in your query range.
### Grouping
By default you just get the total event count of all event types captured by Keytiles in the query range. But if you want to compare / see / distinguish this "total count" by different view points then you can request Keytiles to "group the data" by different things.
  
For example if you want to see event counts / different tileTypes you can use **groupBy=tileType** query parameter. To see the event count distribution regarding the different eventTypes Keytiles captured you can use **groupBy=eventType**. And you can also combine them like **groupBy=eventType,tileType** to get a full decomposition by these two grouping factors.
  
Please refer to the "groupBy" parameter description to see all possible options!
### Limit / threshold
If you have a high traffic website with many many Tiles (content) then you might get back huge data from queries even for a relatively short time range. Experience shows that most of this data might be not important for you in many cases.
Therefore you have the possibility to limit Keytiles response size by defining "send me only the top X" tiles (as most relevant info) and leave out the rest.
Please refer to the "limit" and "threshold" parameter descriptions for more details on endpoints supporting this!

 * OpenAPI spec version: 3.0
 */
import axios from 'axios';
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatApiEndpointLocalErrorCodes = {
    queryRange_from_extended: 'queryRange_from_extended',
    queryRange_to_extended: 'queryRange_to_extended',
    queryRange_extended: 'queryRange_extended',
    queryRange_corrected: 'queryRange_corrected',
    queryRange_from_corrected: 'queryRange_from_corrected',
    queryRange_to_corrected: 'queryRange_to_corrected',
    containerId_missing: 'containerId_missing',
    containerId_invalid: 'containerId_invalid',
    containerSetup_invalid: 'containerSetup_invalid',
    filter_not_supported: 'filter_not_supported',
    sorting_column_not_in_interest: 'sorting_column_not_in_interest',
    groupBy_eventType_not_set: 'groupBy_eventType_not_set',
};
/**
 * To optimize storage and response size Keytiles maps String identifiers to Numerical IDs. These are things like `eventType` or `userAgentType` etc.
These mapping records also keep track on when did we see first or last time the given incoming String.
  
With this endpoint you have the possibility to query these mappings - even for a specific time range - so you can use them as parameters for *Only filters in Event counter queries

 * @summary To query String => numericalId mapping records belong to the Container
 */
export const getV2StatWebhitsContainerIdIdmappings = (containerId, params, options) => {
    return axios.get(`/v2/stat/webhits/${containerId}/idmappings`, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, params), options === null || options === void 0 ? void 0 : options.params) }));
};
/**
 * If you use this "mass query" endpoint then you have to tell explicitly which Tiles data you are curious about - it will not return all Tile data ever (of course, could be millions!)

 * @summary To query data Keytiles stores about content - Tiles.
 */
export const getV2StatWebhitsContainerIdTiles = (containerId, params, options) => {
    return axios.get(`/v2/stat/webhits/${containerId}/tiles`, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, params), options === null || options === void 0 ? void 0 : options.params) }));
};
/**
 * If you are interested in measured traffic regardless which tiles received them then this is the endpoint you should use. It aggregates everything from all tiles.
  
Ideal to display global graphs.
  
You might fine tune the query with the parameters.

 * @summary To query aggregated event counts measured by the Container
 */
export const getV2StatWebhitsContainerIdEventcounts = (containerId, params, options) => {
    return axios.get(`/v2/stat/webhits/${containerId}/eventcounts`, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, params), options === null || options === void 0 ? void 0 : options.params) }));
};
/**
 * Returns the measured event counts segregated by tiles and also information about the tiles themselves.
  
Although you also receive the aggregated counts in the response for comfort you should not use this endpoint if you are not interested in tile level segregation! Then simply use the `/eventcounts` one! This query is more expensive and thus can be significantly slower too.
  
You might fine tune the query with the parameters.

 * @summary To query event counts measure on a tile level basis
 */
export const getV2StatWebhitsContainerIdEventcountsTiles = (containerId, params, options) => {
    return axios.get(`/v2/stat/webhits/${containerId}/eventcounts/tiles`, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, params), options === null || options === void 0 ? void 0 : options.params) }));
};
/**
 * Returns the system clock
  
Since you often phrase queries when you need to include timestamps it makes sense to be able to query the system clock which you can use to calculate potential diff in between your local (machine) clock and the server time. Considering this into queries might help a lot to significantly improve your server queries
  
*note:* This endpoint is actually still coming from API v1 as you can see - we added it here for better visbility only.

 * @summary To query the system clock
 */
export const getV1SystemClock = (options) => {
    return axios.get(`/v1/system/clock`, options);
};
/**
 * Returns the break down for external referrers
  
*note:* This endpoint is actually still coming from API v1 as you can see - we added it here for better visbility only.
  
**IMPORTANT!** You find details in our [query-api v1.0](/swagger-ui/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fkeytiles%2Fkeytiles-public-api%2Fmain%2Fsrc%2Fmain%2Fopenapi%2Fquery-api-v1.yaml#/Referrer%20counters/get_v1_stat_counters__containerId__external_referrers) contract!

 * @summary To query the external referrer distribution counters
 */
export const getV1StatCountersContainerIdExternalReferrers = (containerId, options) => {
    return axios.get(`/v1/stat/counters/${containerId}/external-referrers`, options);
};
//# sourceMappingURL=query-api-v3.js.map