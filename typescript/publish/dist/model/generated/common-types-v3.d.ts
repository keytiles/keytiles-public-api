/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * Common object definitions
 * These object definitions are shared among multiple contracts
 * OpenAPI spec version: 3.0
 */
export type CommonErrorCodes = typeof CommonErrorCodes[keyof typeof CommonErrorCodes];
export declare const CommonErrorCodes: {
    readonly url_invalid: "url_invalid";
    readonly actionToken_internalError: "actionToken_internalError";
    readonly actionToken_missing: "actionToken_missing";
    readonly actionToken_invalid: "actionToken_invalid";
    readonly actionToken_unknownType: "actionToken_unknownType";
    readonly authentication_missing: "authentication_missing";
    readonly authentication_internalError: "authentication_internalError";
    readonly authentication_invalid_credentials: "authentication_invalid_credentials";
    readonly authentication_userDisabled: "authentication_userDisabled";
    readonly authentication_base64DecodeFailed: "authentication_base64DecodeFailed";
    readonly authentication_methodNotSupported: "authentication_methodNotSupported";
    readonly authorization_noPermission: "authorization_noPermission";
    readonly requestParameter_wrongFormat: "requestParameter_wrongFormat";
    readonly requestParameter_missing: "requestParameter_missing";
    readonly requestParameter_invalid: "requestParameter_invalid";
    readonly requestParameter_not_supported: "requestParameter_not_supported";
    readonly requestParameter_pointless: "requestParameter_pointless";
    readonly requestParameter_contradicting: "requestParameter_contradicting";
    readonly requestParameter_conflict: "requestParameter_conflict";
    readonly resourceData_wrongFormat: "resourceData_wrongFormat";
    readonly resourceData_missing: "resourceData_missing";
    readonly resourceData_invalid: "resourceData_invalid";
    readonly resourceData_not_supported: "resourceData_not_supported";
    readonly resourceData_pointless: "resourceData_pointless";
    readonly resourceData_contradicting: "resourceData_contradicting";
    readonly resourceData_conflict: "resourceData_conflict";
    readonly resourceVersion_mismatch: "resourceVersion_mismatch";
    readonly mandatoryEmailSending_failed: "mandatoryEmailSending_failed";
    readonly requestData_wrongFormat: "requestData_wrongFormat";
    readonly requestData_missing: "requestData_missing";
    readonly requestData_invalid: "requestData_invalid";
    readonly requestData_not_supported: "requestData_not_supported";
    readonly requestData_contradicting: "requestData_contradicting";
    readonly query_limit_reached: "query_limit_reached";
    readonly field_deprecated: "field_deprecated";
    readonly underlying_resource_unavailable: "underlying_resource_unavailable";
};
/**
 * This info piece is most useful for 400 - "Bad Request" problems but can be meaningful of course in other scenarios too. It marks the place which has the problem.
 * @nullable
 */
export type ProblemPlaceEnum = typeof ProblemPlaceEnum[keyof typeof ProblemPlaceEnum] | null;
export declare const ProblemPlaceEnum: {
    readonly queryParam: "queryParam";
    readonly urlParam: "urlParam";
    readonly url: "url";
    readonly requestBody: "requestBody";
    readonly requestHeader: "requestHeader";
    readonly responseBody: "responseBody";
    readonly responseHeader: "responseHeader";
    readonly responseStatusCode: "responseStatusCode";
    readonly remoteService: "remoteService";
    readonly cookie: "cookie";
    readonly persistence: "persistence";
    readonly calculated: "calculated";
};
export type ProblemClassSeverity = typeof ProblemClassSeverity[keyof typeof ProblemClassSeverity];
export declare const ProblemClassSeverity: {
    readonly warning: "warning";
    readonly error: "error";
};
export interface ProblemClass {
    severity: ProblemClassSeverity;
    /** The problem in human readable form */
    message: string;
    place?: ProblemPlaceEnum;
    /**
     * If it makes sense it tells you which place was problematic. E.g. if a request parameter should be an Integer but you send in something wrong then "placeName" will tell you exactly which request parameter was wrong.
     * @nullable
     */
    placeName?: string | null;
    /** @nullable */
    errorCodes?: string[] | null;
}
/**
 * Extra data (variables) the endpoint wants to return for programmatic processing.
 * @nullable
 */
export type BaseResponseClassVars = {
    [key: string]: unknown;
} | null;
export interface BaseResponseClass {
    /** The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started */
    requestReceivedAt: number;
    /**
     * Number of milliseconds the processing took on server side
     * @nullable
     */
    processingTookMillis?: number | null;
    /**
     * List of errors/warnings
     * @nullable
     */
    problems?: ProblemClass[] | null;
    /**
     * Extra data (variables) the endpoint wants to return for programmatic processing.
     * @nullable
     */
    vars?: BaseResponseClassVars;
}
export type MessageResponseClassAllOf = {
    /** The human readable message */
    message?: string;
};
export type MessageResponseClass = BaseResponseClass & MessageResponseClassAllOf;
/**
 * @nullable
 */
export type ResponseContainerInfoClass = {
    /** The ID of the container - this is typically a UUID like value */
    id: string;
    /** The name of the container */
    name?: string;
} | null;
export type ContainerResponseClassAllOf = {
    container: ResponseContainerInfoClass;
};
export type ContainerResponseClass = BaseResponseClass & ContainerResponseClassAllOf;
export type ContainerQueryRangeResponseClassAllOf = {
    /** In the request you requested data starting by this UNIX timestamp in UTC (seconds since Epoch) */
    requestedFromTimestamp: number;
    /** In the request you requested data until this UNIX timestamp in UTC (seconds since Epoch) */
    requestedToTimestamp: number;
    /** This response contains data starting by this UNIX timestamp in UTC (seconds since Epoch) - will be always rounded to at least minutes or even more (see section "Interval of your interest" above!) */
    dataFromTimestamp: number;
    /** This response contains data until this UNIX timestamp in UTC (seconds since Epoch) */
    dataToTimestamp: number;
};
export type ContainerQueryRangeResponseClass = ContainerResponseClass & ContainerQueryRangeResponseClassAllOf;
/**
 * Defines the beginning of the query range - you are interested in data which time is >= than this timestamp.
  
Format is mixed. It can be
 * a UNIX timestamp in UTC (seconds since Epoch) e.g.: `1657261221` - means 2022-07-08 6:20:21 GMT
   (note: server and client clock might be different! see: /v2/system/clock endpoint to query server time)
 * a relative time spec compared to current time in form of 'now[-X<m|h|d>]' where 'm' means minutes, 'h' means hours and 'd' means days,
   e.g.: `now-10m` means 10 minutes earlier compared to current time,
   `now-2h` means 2 hours earlier and so on
   
This must point to the past!   (note: server validates according to his own clock!)

 */
export type FromTimestampParameter = string;
/**
 * Defines the end of the query range - you are interested in data which time is <= than this timestamp.
  
**Default value:** the current timestamp, so 'now' if you do not specify this parameter.
  
Format is mixed. It can be
 * a UNIX timestamp in UTC (seconds since Epoch) e.g.: `1657261221` - means 2022-07-08 6:20:21 GMT
   (note: server and client clock might be different! see: /v2/system/clock endpoint to query server time)
 * a relative time spec compared to current time in form of 'now[-X<m|h|d>]' where 'm' means minutes, 'h' means hours and 'd' means days,
   e.g.: `now-10m` means 10 minutes earlier compared to current time,
   `now-2h` means 2 hours earlier and so on
   
Can not point to the future!   (note: server validates according to his own clock!)

 */
export type ToTimestampParameter = string;
