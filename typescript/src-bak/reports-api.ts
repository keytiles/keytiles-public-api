/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
    "/v1/reports/containers/setup/rest/{containerId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * To query existing report setups belong to the Container
         * @description With this endpoint you have the possibility to query all report setups of a Data Container.
         *
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description You receive the list of all setups. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ListContainerReportSetupsResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials or not at all */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        put?: never;
        /**
         * To create a new report setup belongs to the Container
         * @description You can assign an ID for this setup on client side as well but if you don't then a new ID will be generated (and returned in response header).
         *
         *     For now only Admins of Data Containers can create a report setup.
         *
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["ReportSetup"];
                };
            };
            responses: {
                /** @description The report setup resouce is created. The ID of this new report setup is returned in response header. */
                201: {
                    headers: {
                        /** @description The ID of the new report setup */
                        "X-ReportSetupId"?: string;
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description There were problems with the request or the resource you sent on this request - more details you get in the response. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials or not at all */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description Some preconditions are not OK. For example, you assigned an ID on client side but that ID is already taken. More details you find in the response. */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/reports/containers/setup/rest/{containerId}/{reportSetupId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** To query a specific report setup of the Container */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of the report setup belongs to the Data Container */
                    reportSetupId: components["parameters"]["reportSetupId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The report setup was found and returned to you. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ReportSetup"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report setup does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        /**
         * To modify an existing report setup.
         * @description The 'resourceVersion' field is very important here - it must match with the version the server currently has otherwise you will get a 409 error. This mechanism helps to detect possible race conditions.
         *
         *     For now only Admins of Data Containers can modify a report setup.
         *
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of the report setup belongs to the Data Container */
                    reportSetupId: components["parameters"]["reportSetupId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["ReportSetup"];
                };
            };
            responses: {
                /** @description The report setup was modified successfully. This means that the 'resourceVersion' was incremented by one on server side (also update in your local copy!). */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description There were problems with the request or the resource you sent on this request - more details you get in the response. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials or not at all */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report setup does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description Some preconditions are not OK. Most likely the 'resourceVersion' did not match because there was a race condition. More details you find in the response. */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        post?: never;
        /**
         * To delete a specific report setup of the Container as well as all previously generated report instances.
         * @description In case you do not want to lose all previous instances consider simply just remove the 'schedule' of the report instead of deleting it! If you do so then the report will not run automatically anymore.
         *
         *     For now only Admins of Data Containers can delete a report setup.
         *
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of the report setup belongs to the Data Container */
                    reportSetupId: components["parameters"]["reportSetupId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The report setup and all report instances were deleted successfully. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ReportSetup"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report setup does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/reports/containers/setup/rest/{containerId}/{reportSetupId}/instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** To query (list) all availale report instance IDs of a given ReportSetup - available in the Data Container */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of the report setup belongs to the Data Container */
                    reportSetupId: components["parameters"]["reportSetupId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description You receive the list of all report instance IDs. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ListContainerReportInstancesResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report setup does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        put?: never;
        /**
         * To generate (create) a new report instance of this report setup.
         * @description When triggered manually then the report generation starts immediately. You can fine tune the report generation (mostly for testing purposes) - see request body!
         *     Please note that a report generation might take time.
         *
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of the report setup belongs to the Data Container */
                    reportSetupId: components["parameters"]["reportSetupId"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["GenerateReportRequestClass"];
                };
            };
            responses: {
                /** @description The report generation is accepted and will take place soon. This might take for a while...
                 *     An ID is immediately generated for this report instance. And **please note:** returned in response header!
                 *     By knowing the ID you can query this report instance later.
                 *      */
                202: {
                    headers: {
                        /** @description The ID of this new report instance */
                        "X-ReportInstanceId"?: string;
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description There were problems with the request or the resource you sent on this request - more details you get in the response. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials or not at all */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report setup does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/reports/containers/instance/rest/{containerId}/{reportInstanceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** To query a specific report instance with the given ID of the Data Container */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of a specific (generated) report instance belongs to the Data Container */
                    reportInstanceId: components["parameters"]["reportInstanceId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Returns the generated report instance. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GetContainerReportInstanceResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report instance does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        /** To permanently delete a specific report instance - after this this report is not available anymore. */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description ID of the container to query stat from */
                    containerId: components["parameters"]["containerId"];
                    /** @description ID of a specific (generated) report instance belongs to the Data Container */
                    reportInstanceId: components["parameters"]["reportInstanceId"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The report instance was deleted successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description Authentication failed - you provided invalid credentials */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description You do not have permission to do this with the given credentials */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
                /** @description The container does not exist (or disabled) or the requested report instance does not exist - more details in the response! */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MachineReadableReportsEndpointMessageResponseClass"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
};
export type webhooks = Record<string, never>;
export type components = {
    schemas: {
        /** @enum {string} */
        ReportsEndpointLocalErrorCodes: "containerId_missing" | "containerId_invalid" | "reportSetupId_invalid";
        /** @description NOTE! Error codes is an Enum. Unfortunately in OpenApi (so far) there is no possibility to provide description for Enum values. But we have detailed description of each error codes! Please check the OpenApi file in our Github repo - you find them as comments for each Enum values! */
        ReportsEndpointErrorCodes: components["schemas"]["ReportsEndpointLocalErrorCodes"] & components["schemas"]["CommonErrorCodes"];
        ReportsEndpointProblemClass: components["schemas"]["ProblemBaseClass"] & {
            /** @default [] */
            errorCodes: components["schemas"]["ReportsEndpointErrorCodes"][] | null;
        };
        MachineReadableReportsEndpointMessageResponseClass: components["schemas"]["MessageResponseClass"] & {
            /**
             * @description List of errors/warnings
             * @default []
             */
            problems: components["schemas"]["ReportsEndpointProblemClass"][] | null;
        };
        ListContainerReportSetupsResponseClass: {
            /**
             * @description All avaiable report setup IDs.
             * @example [
             *       "reportSetupId"
             *     ]
             */
            reportSetupIds?: string[];
        } & components["schemas"]["ContainerResponseClass"];
        GetContainerReportSetupResponseClass: {
            reportSetup?: components["schemas"]["ReportSetup"];
        } & components["schemas"]["ContainerResponseClass"];
        /** @enum {string} */
        ReportRecipientsRoles: "view" | "admin" | "developer";
        /** @description This is an optional setup - controlls who will receive these reports.
         *
         *     If not given at all then ALL Data Container users will get the report. Otherwise if given then Keytiles users who are matching to ANY of the given criteria will receive the report.
         *      */
        ReportRecipients: {
            /** @description Optional entry. List of specific Keytiles users (email or ID) to send the reports to. The users who are listed here will get the reports for sure if
             *      * they are not disabled in Keytiles (can not log in)
             *      * they are not associated with the Data Container anyhow
             *      */
            users?: string[];
            /** @description Optional entry. All Data Container users who has ANY of the listed roles will receive this report. */
            roles?: components["schemas"]["ReportRecipientsRoles"][];
        } | null;
        /** @enum {string} */
        ReportQueryPlugin: "eventCountPlugin" | "campaignPerformancePlugin" | "socialPerformancePlugin" | "linksPerformancePlugin" | "tagsPerformancePlugin" | "visitorBehaviorPlugin";
        /** @description A report can contain multiple queries. This object describes one query of those. */
        ReportQuery: {
            /** @description The unique ID (within the report) of this query - UUID style. In concrete report instances this helps to identify the result of this query within the whole report. */
            id?: string;
            /** @description Title, description - of this query of the report. */
            metaData: components["schemas"]["MetaData"];
            /** @description It is possible to temporarily disable a query. This way you do not lose its setup, so you can re-enable it later again. */
            isDisabled?: boolean;
            /** @description Which query plugin to use for this query? Each plugin provides different possibilities. */
            plugin: components["schemas"]["ReportQueryPlugin"];
            /** @description The parameters a query plugin needs depends on the plugin. These key-value pairs provide the setup how the query plugin will generate this part of the report. */
            parameters?: {
                /** @description If set to TRUE then you get a break-down in time interval. The interval is driven by your schedule.
                 *      * Hourly schedule: you get 15 minutes break-down
                 *      * Daily schedule: you get an hourly breakdown
                 *      * Weekly schedule: you get a daily breakdown
                 *      * Monthly schedule: you get a weekly breakdown
                 *      */
                groupByTime?: boolean;
                /** @description Which event counts to include into the report? E.g. "pageview", or custom events e.g. "30 seconds passed". These will be the columns in your report. You can also construct formulas using the pure eventNames.
                 *      */
                eventsIncluded?: string[];
                /**
                 * @description If set to TRUE then you get a break-down on Tile level - otherwise just sum of the traffic of all Tiles.
                 *
                 * @default false
                 */
                groupByTiles?: boolean;
                /**
                 * @description If set to TRUE then you get a break-down based on content structure (=tileGroupPath). Can not be used together with 'groupByTiles'!
                 *
                 * @default false
                 */
                groupByTileGroupPaths?: boolean;
                /** @description You can limit how deep you want the report to go down in the content structure. E.g. if you set it to 1 that means you get a break down only for first level.
                 *      */
                groupByTileGroupPathMaxDepth?: number;
                /** @description Optional param. How many rows you want to display maximum? Only makes sense if 'groupByTiles=true' or 'groupByTileGroupPaths=true'. Using the 'performanceDescendingOrder' basically you can see the top performing ones, or the worst performing ones - up to you.
                 *      */
                limit?: number;
                /** @description Sort the list based on these "eventsIncluded"
                 *      */
                sortBy?: string[];
                /** @default true */
                performanceDescendingOrder?: boolean;
                /** @description Data filter option. Comma separated list of tile types you want to limit the query for. If you list more values here then they are interpreted with an OR operator.
                 *
                 *     IMPORTANT! You can not use this together with `tileTypeIsNot` parameter! You can only use this or that but not both.
                 *
                 *     In the list you can either use: * The name of the type ('frontpage', 'page', 'article', ...), or * The numeric ID of the tile type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                 *      */
                tileTypesOnly?: string;
                /**
                 * @description Data filter option. Comma separated list of matchers (see below) which returns counters only for those Tiles who's tileGroupPath is matching to one of the listed matchers. So if you list more values here then they are interpreted with an OR operator.
                 *
                 *     note: if you have comma in your matcher (strange, but ok...) you can escape that with `\\` character!
                 *
                 *     You can use the **'\*'** character to match any substring. But where and how you put this Asterisk character matters! Let us show you how through an example!
                 *     Let's assume you have articles and pages (Tiles) in the following content areas:
                 *
                 *     * /auto * /tech * /tech/mobile-rumours * /tech/mobile * /tech/mobile/android * /tech/mobile/ios * /politics
                 *
                 *     And now you execute queries with two different **tileGroupPathMatchingOnly** settings: 1. **"/tech/mobile\*"** and 1. **"/tech/mobile/\*"**
                 *     In the first query **"/tech/mobile\*"** would match for everything begins with "/tech/mobile" string. So this would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* Tiles but also would include *"/tech/mobile-rumours"* Tiles. Which are clearly two different areas right?
                 *
                 *     But what if you want to really limit for Tiles under the *"/tech/mobile"* area?
                 *
                 *     Well then you can use the second query value: **"/tech/mobile/\*"**. This would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* but would NOT include *"/tech/mobile-rumours"* anymore - as that is not a match anymore. But we are not done yet! Please note: this would also include Tiles under *"/tech/mobile/"* group itself. Because **"/\*"** means "everything which is under this group"
                 *
                 * @example /tech/mobile/*, *\/errors/*
                 */
                tileGroupPathMatchingOnly?: string;
            } & {
                [key: string]: unknown;
            };
        };
        ReportSetup: {
            /** @description The unique ID of this report setup - UUID style */
            id: string;
            /** @description Title, description and changelog - of this report. */
            metaData: components["schemas"]["MetaData"];
            /** @description Controlls when will the report run automatically. If you do not schedule the report then the report is only generated when you manually trigger it. */
            schedule?: components["schemas"]["Schedule"];
            /** @description Optionally you can fine grain which Data Container users will receive this report when generated. */
            recipients?: components["schemas"]["ReportRecipients"];
            /**
             * @description Queries of this report.
             * @default []
             */
            queries: components["schemas"]["ReportQuery"][] | null;
            /** @description This is the resource version (which is automatically incremented by every change). When you do an update (PUT) you need to send it back! The server will check if it is matching with the resource version he has. If not then that means someone else already did an update in the meantime therefore your request can not be accepted - otherwise you may overwrite the changes someone did. */
            resourceVersion: number;
        };
        DataTableDataColumn: {
            label?: string;
            collapseFunction?: string;
        };
        DataTableAxisColumn: {
            label?: string;
        };
        DataTableColumn: components["schemas"]["DataTableAxisColumn"] | components["schemas"]["DataTableDataColumn"];
        DataTableCell: string | number;
        DataTableRow: components["schemas"]["DataTableCell"][];
        /** @description DataTable is the output of queries - a self contained table of data with Axis columns (optional) and >1 Data columns. Plus of course the data rows. */
        DataTable: {
            /** @description List of "Axis" columns. Order in array is important as the index of the entry tells the position. */
            columns: components["schemas"]["DataTableColumn"][];
            /** @default [] */
            rows: components["schemas"]["DataTableRow"][];
        };
        ReportInstanceSection: {
            /** @description The title of this section - copied from the ReportSetup appropriate Query part which produced this section when this instance was generated. */
            title?: string;
            /** @description This is a longer description of this section - copied from the ReportSetup appropriate Query part which produced this section when this instance was generated. */
            description?: string;
            /** @default [] */
            dataTables: components["schemas"]["DataTable"][];
        };
        /** @description This is a specific instance of a ReportSetup which was generated at a certain point in time. Keytiles stores these reports for a while.
         *     A report instance consists of sections - each section is generated by a query.
         *      */
        ReportInstance: {
            /** @description The unique ID of this report setup - UUID style */
            id?: string;
            /** @description The ID of the ReportSetup this instance belongs to. */
            parentReportSetupId?: string;
            /**
             * Format: int32
             * @description The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
             * @example 1543355710
             */
            createdAt?: number;
            /** @description Tells if this report instance is a result of a test generation only or not. */
            isTestOnly?: boolean;
            /** @description In case the report generation was triggered manually by someone then this field contains the ID of the user triggered the generation. */
            generatorUserId?: string | null;
            /** @description In case the report generation was triggered manually by someone then this field contains the Nickname of the user triggered the generation. */
            generatorUserNickname?: string | null;
            /** @description The title of the report - copied from the ReportSetup metaData when this instance was generated. */
            title?: string;
            /** @description This is a longer description of the report - copied from the ReportSetup metaData when this instance was generated. */
            description?: string | null;
            /** @default [] */
            sections: components["schemas"]["ReportInstanceSection"][];
        };
        AvailableReportInstance: {
            /** @example reportInstanceId */
            id?: string;
            /**
             * Format: int32
             * @description The server time in UNIX timestamp in UTC (seconds since Epoch) when this instance was created
             * @example 1543355710
             */
            createdAt?: number;
            /** @description Tells if this report instance is marked as 'test only' or not. */
            isTestOnly?: boolean;
        };
        ListContainerReportInstancesResponseClass: {
            /** @description Report instances belong to this report setup. */
            ofReportSetupId?: string;
            /** @description All available report instances - ordered by creation timestamp descending */
            availableInstances?: components["schemas"]["AvailableReportInstance"][];
        } & components["schemas"]["ContainerResponseClass"];
        GetContainerReportInstanceResponseClass: {
            reportInstance?: components["schemas"]["ReportInstance"];
        } & components["schemas"]["ContainerResponseClass"];
        GenerateReportRequestClass: {
            /** @description Set it to TRUE if you just want to test the report generation.
             *     In this case the recipients (if set in report setup) will not be notified about this report at all. And only the user who generated it will receive a notification when report is ready to view. But apart from this the full report will be generated.
             *      */
            isTestOnly?: boolean;
            /** @description A report might contain multiple ReportQuery parts, all of them has its unique ID within the report.
             *     It is possible to generate only specific queries instead of the full report - by providing a list of those ReportQuery IDs here.
             *     **BUT** if you do this, then this also sets 'isTestOnly' to TRUE! So the generated ReportInstance considered to be a test only.
             *      */
            executeQueryIdsOnly?: string[];
            /** @description If this is set to TRUE then recipients will not receive any notification from Keytiles when this Report Instance is created.
             *     **IMPORTANT!** Use this with caution! This option was introduced mostly because of internal reasons under certain circumstances.
             *      */
            skipNotifications?: boolean;
        };
        /**
         * @description This info piece is most useful for 400 - "Bad Request" problems but can be meaningful of course in other scenarios too. It marks the place which has the problem.
         * @enum {string|null}
         */
        ProblemPlaceEnum: "queryParam" | "urlParam" | "url" | "requestBody" | "requestHeader" | "responseBody" | "responseHeader" | "responseStatusCode" | "remoteService" | "cookie" | "persistence" | "calculated" | null;
        /** @enum {string} */
        CommonErrorCodes: "url_invalid" | "actionToken_internalError" | "actionToken_missing" | "actionToken_invalid" | "actionToken_unknownType" | "authentication_missing" | "authentication_internalError" | "authentication_invalid_credentials" | "authentication_userDisabled" | "authentication_base64DecodeFailed" | "authentication_methodNotSupported" | "authorization_noPermission" | "requestParameter_wrongFormat" | "requestParameter_missing" | "requestParameter_invalid" | "requestParameter_not_supported" | "requestParameter_pointless" | "requestParameter_contradicting" | "requestParameter_conflict" | "resourceData_wrongFormat" | "resourceData_missing" | "resourceData_invalid" | "resourceData_not_supported" | "resourceData_pointless" | "resourceData_contradicting" | "resourceData_conflict" | "resourceVersion_mismatch" | "mandatoryEmailSending_failed" | "requestData_wrongFormat" | "requestData_missing" | "requestData_invalid" | "requestData_not_supported" | "requestData_contradicting" | "query_limit_reached" | "field_deprecated" | "underlying_resource_unavailable";
        ProblemBaseClass: {
            /**
             * @example warning|error
             * @enum {string}
             */
            severity: "warning" | "error";
            /** @description The problem in human readable form */
            message: string;
            place?: components["schemas"]["ProblemPlaceEnum"];
            /** @description If it makes sense it tells you which place was problematic. E.g. if a request parameter should be an Integer but you send in something wrong then "placeName" will tell you exactly which request parameter was wrong. */
            placeName?: string | null;
            /** @default [] */
            errorCodes: components["schemas"]["CommonErrorCodes"][] | null;
        };
        BaseResponseClass: {
            /**
             * Format: int32
             * @description The server time in UNIX timestamp in UTC (seconds since Epoch) when this response was received and processing was started
             * @example 1543355710
             */
            requestReceivedAt: number;
            /**
             * Format: int32
             * @description Number of milliseconds the processing took on server side
             */
            processingTookMillis?: number | null;
            /**
             * @description List of errors/warnings
             * @default []
             */
            problems: components["schemas"]["ProblemBaseClass"][] | null;
            /** @description Extra data (variables) the endpoint wants to return for programmatic processing. */
            vars?: {
                [key: string]: unknown;
            } | null;
        };
        ResponseContainerInfoClass: {
            /**
             * @description The ID of the container - this is typically a UUID like value
             * @example d72c640b-d963-4789-bd48-9a38f381eaa6
             */
            id: string;
            /**
             * @description The name of the container
             * @example My Website
             */
            name?: string;
        } | null;
        ContainerResponseClass: components["schemas"]["BaseResponseClass"] & {
            container: components["schemas"]["ResponseContainerInfoClass"];
        };
        MessageResponseClass: components["schemas"]["BaseResponseClass"] & {
            /** @description The human readable message */
            message?: string;
        };
        /** @description Defines a change - who changed what, when? */
        ChangelogEntry: {
            /**
             * Format: int32
             * @description The time of the change as UNIX timestamp in UTC (seconds since Epoch).
             */
            time: number;
            /** @description This is the nickname of the Keytiles user who made the change. So no hard user link here - just take it easy... */
            who: string;
            /** @description Some description added to this change. Can be generated and/or amended with user input too. */
            comment?: string;
        };
        MetaData: {
            /** @description Mandatory field. The title of the entity. */
            title: string;
            /** @description Optional field. This is a longer description of what this entity is about. */
            description?: string;
            /** @description Changes which were made. Append only log - in time ascending order. */
            changelog?: components["schemas"]["ChangelogEntry"][];
            /** @description The major version of the MetaData schema which was used when this object was created. This helps to evolve MetaData over time. */
            majorVersion: number;
        };
        /**
         * @description Name of the days we use in day masks.
         * @enum {string}
         */
        ScheduleDayName: "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun";
        /** @description Encodes scheduling tailored for hourly execution. */
        HourlyScheduleSetup: {
            /**
             * @description Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution first? From this time the action is shcheduled every hour.
             *
             *     For example if you set it to "09:15" then first execution happens at 09:15, the next one at 10:15 then 11:15 and so on.
             *
             * @example 09:15
             */
            firstTime: string;
            /**
             * @description Optional setting. This is an "HH:MM" formatted time descriptor. Means: within a day triggering will happen only if the current time is <= than this time.
             *
             *     For example, if `firstTime="09:15"` then actually the last execution of the action will happen at "17:15".
             *
             *     In case not given then scheduling will happen within the day every hour starting from `firstTime`.
             *
             * @example 18:00
             */
            untilTime?: string;
            /** @description Optional setting. If given then scheduling will happen only on these days. This is a day mask basically. */
            dayNames?: components["schemas"]["ScheduleDayName"][];
        };
        /** @description Encodes scheduling tailored for daily execution. */
        DailyScheduleSetup: {
            /**
             * @description Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
             *
             * @example 09:00
             */
            triggerTime: string;
            /** @description Optional setting. If given then scheduling will happen only on these days. This is a day mask basically. */
            dayNames?: components["schemas"]["ScheduleDayName"][];
        };
        /** @description Encodes scheduling tailored for weekly execution. */
        WeeklyScheduleSetup: {
            /**
             * @description Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
             *
             * @example 09:00
             */
            triggerTime: string;
            /** @default Mon */
            dayName: components["schemas"]["ScheduleDayName"];
        };
        /** @description Encodes scheduling tailored for monthly execution. */
        MonthlyScheduleSetup: {
            /**
             * @description Mandatory element. This is an "HH:MM" formatted time descriptor. Means: within a day what time should we trigger the execution?
             *
             * @example 09:00
             */
            triggerTime: string;
            /**
             * @description Optional element. To pick up the day when the report is triggered you have a few options. If not given then simply it will be 'firstDay'.
             * @default firstDay
             */
            dayName: components["schemas"]["ScheduleDayName"] | ("firstDay" | "lastDay");
        };
        /** @description Describes a Schedule of something. As of now you have basically 4 types: hourly, daily, weekly and Monthly schedules. */
        Schedule: {
            /**
             * @description Describes which type of schedule is this?
             * @enum {string}
             */
            type: "hourly" | "daily" | "weekly" | "monthly";
            setup: components["schemas"]["HourlyScheduleSetup"] | components["schemas"]["DailyScheduleSetup"] | components["schemas"]["WeeklyScheduleSetup"] | components["schemas"]["MonthlyScheduleSetup"];
            /** @description Encodes the time zone offset from UTC - all things like time and even the days(!) are given using this offset */
            tzOffset: number;
            /** @description The major version of the Schedule schema which was used when this object was created. This helps to evolve Schedules over time. */
            majorVersion: number;
        } | null;
    };
    responses: never;
    parameters: {
        /** @description ID of the report setup belongs to the Data Container */
        reportSetupId: string;
        /** @description ID of a specific (generated) report instance belongs to the Data Container */
        reportInstanceId: string;
        /** @description ID of the container to query stat from */
        containerId: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
};
export type ReportsEndpointLocalErrorCodes = components['schemas']['ReportsEndpointLocalErrorCodes'];
export type ReportsEndpointErrorCodes = components['schemas']['ReportsEndpointErrorCodes'];
export type ReportsEndpointProblemClass = components['schemas']['ReportsEndpointProblemClass'];
export type MachineReadableReportsEndpointMessageResponseClass = components['schemas']['MachineReadableReportsEndpointMessageResponseClass'];
export type ListContainerReportSetupsResponseClass = components['schemas']['ListContainerReportSetupsResponseClass'];
export type GetContainerReportSetupResponseClass = components['schemas']['GetContainerReportSetupResponseClass'];
export type ReportRecipientsRoles = components['schemas']['ReportRecipientsRoles'];
export type ReportRecipients = components['schemas']['ReportRecipients'];
export type ReportQueryPlugin = components['schemas']['ReportQueryPlugin'];
export type ReportQuery = components['schemas']['ReportQuery'];
export type ReportSetup = components['schemas']['ReportSetup'];
export type DataTableDataColumn = components['schemas']['DataTableDataColumn'];
export type DataTableAxisColumn = components['schemas']['DataTableAxisColumn'];
export type DataTableColumn = components['schemas']['DataTableColumn'];
export type DataTableCell = components['schemas']['DataTableCell'];
export type DataTableRow = components['schemas']['DataTableRow'];
export type DataTable = components['schemas']['DataTable'];
export type ReportInstanceSection = components['schemas']['ReportInstanceSection'];
export type ReportInstance = components['schemas']['ReportInstance'];
export type AvailableReportInstance = components['schemas']['AvailableReportInstance'];
export type ListContainerReportInstancesResponseClass = components['schemas']['ListContainerReportInstancesResponseClass'];
export type GetContainerReportInstanceResponseClass = components['schemas']['GetContainerReportInstanceResponseClass'];
export type GenerateReportRequestClass = components['schemas']['GenerateReportRequestClass'];
export type ProblemPlaceEnum = components['schemas']['ProblemPlaceEnum'];
export type CommonErrorCodes = components['schemas']['CommonErrorCodes'];
export type ProblemBaseClass = components['schemas']['ProblemBaseClass'];
export type BaseResponseClass = components['schemas']['BaseResponseClass'];
export type ResponseContainerInfoClass = components['schemas']['ResponseContainerInfoClass'];
export type ContainerResponseClass = components['schemas']['ContainerResponseClass'];
export type MessageResponseClass = components['schemas']['MessageResponseClass'];
export type ChangelogEntry = components['schemas']['ChangelogEntry'];
export type MetaData = components['schemas']['MetaData'];
export type ScheduleDayName = components['schemas']['ScheduleDayName'];
export type HourlyScheduleSetup = components['schemas']['HourlyScheduleSetup'];
export type DailyScheduleSetup = components['schemas']['DailyScheduleSetup'];
export type WeeklyScheduleSetup = components['schemas']['WeeklyScheduleSetup'];
export type MonthlyScheduleSetup = components['schemas']['MonthlyScheduleSetup'];
export type Schedule = components['schemas']['Schedule'];
export type ParameterReportSetupId = components['parameters']['reportSetupId'];
export type ParameterReportInstanceId = components['parameters']['reportInstanceId'];
export type ParameterContainerId = components['parameters']['containerId'];
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
