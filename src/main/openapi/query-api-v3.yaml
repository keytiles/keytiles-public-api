openapi: 3.0.1

info:
  version: '3.0'
  title: Keytiles Statistics query API
  description: >
            
            # Disclaimer
            
            **PLEASE NOTE! This is an early release of v2 API which is currently in Beta test phase!**  
            This means things can still change!
             
            # Overview
            
            This API provides endpoints to query statistics data stored by Keytiles service.  
              
            To specify / fine tune queries you use query parameters which we can group into a few groups.  
              
            ### Query range
            
            To make queries you need to specify the query time range. To do that you can use the:
            
             * **fromTimestamp** - Start of your query range inclusive (>=). This is a UNIX timstamp (seconds since Epoch, UTC).
             
             * **toTimestamp** - End of your query range inclusive (<=). This is either a UNIX timestamp or "now" as a string meaning current time
            
            ### Filtering
            
            Optionally you can filter the data due to several criteria.  
              
            For example if you are interested in only "view" event types then you can use the **eventTypesOnly=view** filter parameter.  
            Or you can also filter for **tileIdsOnly=tileId1,tileId2** if you are just interested in specific tiles stat data.  
              
            For complete list please check the query parameters of the endpoints! Look for "***Only**" parameters!
            
            ### Details - your interest
            
            By default only the most relevant details are returned however in several endpoints you can definitely ask for more. You can do
            this using the **interest** query parameter.  
              
            For example if you query the event counts for Tiles what you will get back by default is only the total number of events registered in
            your query range.
            
            ### Grouping
            
            By default you just get the total event count of all event types captured by Keytiles in the query range. But if you want to
            compare / see / distinguish this "total count" by different view points then you can request Keytiles to "group the data" by
            different things.  
              
            For example if you want to see event counts / different tileTypes you can use **groupBy=tileType** query parameter. To see
            the event count distribution regarding the different eventTypes Keytiles captured you can use **groupBy=eventType**. And
            you can also combine them like **groupBy=eventType,tileType** to get a full decomposition by these two grouping factors.  
              
            Please refer to the "groupBy" parameter description to see all possible options!
            
            ### Limit / threshold
            
            If you have a high traffic website with many many Tiles (content) then you might get back huge data from queries even for a relatively
            short time range. Experience shows that most of this data might be not important for you in many cases.
            
            Therefore you have the possibility to limit Keytiles response size by defining "send me only the top X" tiles (as most relevant info)
            and leave out the rest.
            
            Please refer to the "limit" and "threshold" parameter descriptions for more details on endpoints supporting this!
            
servers:
- url: https://api.keytiles.com/api
  description: PROD server
- url: https://api-test.keytiles.com/api
  description: TEST server
   
tags:
- name: System
  description: Queries for system values
- name: WebHits - Event counters
  description: Query measured event statistics in Containers which are collecting website analytics
- name: Referrer counters
  description: Queries for referrer statistics
- name: Tiles
  description: Queries related to Tiles
- name: Other queries
  description: Queries help you to know more about your visitors



paths:

  '/v2/stat/webhits/{containerId}/idmappings':
  
    get:
      summary: "To query String => numericalId mapping records belong to the Container"
      tags:
      - Other queries
      description: >
                To optimize storage and response size Keytiles maps String identifiers to Numerical IDs. These are things like
                `eventType` or `userAgentType` etc.  
                
                These mapping records also keep track on when did we see first or last time the given incoming String.  
                  
                With this endpoint you have the possibility to query these mappings - even for a specific time range - so
                you can use them as parameters for *Only filters in Event counter queries
      parameters:
        - $ref: 'common-types-v3.yaml#/components/parameters/containerId'
        - $ref: 'common-types-v3.yaml#/components/parameters/fromTimestamp'
        - $ref: 'common-types-v3.yaml#/components/parameters/toTimestamp'
        - $ref: '#/components/parameters/mappingTypes'
        - $ref: '#/components/parameters/includeFirstLastSeenTs'

      security:
      - basicAuth: []

      responses:
        '200':
          description: "OK response"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetIdMappingsResponseClass'
        '404':
          description: "The given containerId does not exist"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '401':
          description: "Authentication failed - you provided invalid credentials or not provided credentials at all"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '403':
          description: "You have no permission to read statistics of the given Container"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '400':
          description: "Something was wrong with the request"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'


  '/v2/stat/webhits/{containerId}/tiles':
  
    get:
      summary: "To query data Keytiles stores about content - Tiles."
      description: >
                    If you use this "mass query" endpoint then you have to tell explicitly which Tiles data you are
                    curious about - it will not return all Tile data ever (of course, could be millions!)
      tags:
      - Tiles
      parameters:
        - $ref: 'common-types-v3.yaml#/components/parameters/containerId'
        - name: tileIdsOnly
          in: query
          required: true
          schema:
            type: string
          description: >
                        Comma separated list of tileIds you want to limit the query for.  
                          
                        note: if you have comma in your tileIds (strange, but ok...) you can escape that with `\\` character!  
          example: 'tile123,tile456,tile789'

      security:
      - basicAuth: []

      responses:
        '200':
          description: "OK response"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetTilesResponseClass'
        '404':
          description: "The given containerId does not exist"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '401':
          description: "Authentication failed - you provided invalid credentials or not provided credentials at all"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '403':
          description: "You have no permission to read statistics of the given Container"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '400':
          description: "Something was wrong with the request"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'


  '/v2/stat/webhits/{containerId}/eventcounts':
  
    get:
      summary: "To query aggregated event counts measured by the Container"
      tags:
      - WebHits - Event counters
      description: >
                If you are interested in measured traffic regardless which tiles received them then this is the endpoint
                you should use. It aggregates everything from all tiles. 
                  
                Ideal to display global graphs.
                  
                You might fine tune the query with the parameters.  
      parameters:
        - $ref: 'common-types-v3.yaml#/components/parameters/containerId'
        - $ref: 'common-types-v3.yaml#/components/parameters/fromTimestamp'
        - $ref: 'common-types-v3.yaml#/components/parameters/toTimestamp'
        - $ref: '#/components/parameters/interest'
        - $ref: '#/components/parameters/groupBy'
        - $ref: '#/components/parameters/eventTypesOnly'
        - $ref: '#/components/parameters/tileTypesOnly'
        - $ref: '#/components/parameters/tileTypeIsNot'
        - $ref: '#/components/parameters/userAgentTypesOnly'
        - $ref: '#/components/parameters/tileGroupPathMatchingOnly'
        - $ref: '#/components/parameters/visitorTypesOnly'
        - $ref: '#/components/parameters/tileLanguagesOnly'
        - $ref: '#/components/parameters/primaryTagsOnly'
        - $ref: '#/components/parameters/secondaryTagsOnly'
        - $ref: '#/components/parameters/eventSourceTypesOnly'
        - $ref: '#/components/parameters/eventSourceNamesOnly'
        - $ref: '#/components/parameters/trafficSourceTypesOnly'
        - $ref: '#/components/parameters/trafficSourceNamesOnly'
        - $ref: '#/components/parameters/campaignsOnly'
        - $ref: '#/components/parameters/campaignMediumsOnly'
        - $ref: '#/components/parameters/campaignContentsOnly'

      security:
      - basicAuth: []

      responses:
        '200':
          description: "OK response"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EventCountersResponseClass'
        '404':
          description: "The given containerId does not exist"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '401':
          description: "Authentication failed - you provided invalid credentials or not provided credentials at all"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '403':
          description: "You have no permission to read statistics of the given Container"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '400':
          description: "Something was wrong with the request"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'


  '/v2/stat/webhits/{containerId}/eventcounts/tiles':
  
    get:
      summary: "To query event counts measure on a tile level basis"
      tags:
      - WebHits - Event counters
      description: >
                Returns the measured event counts segregated by tiles and also information about the tiles themselves.  
                  
                Although you also receive the aggregated counts in the response for comfort you should not use this endpoint
                if you are not interested in tile level segregation! Then simply use the `/eventcounts` one! This query is more
                expensive and thus can be significantly slower too.  
                  
                You might fine tune the query with the parameters.  
      parameters:
        - $ref: 'common-types-v3.yaml#/components/parameters/containerId'
        - $ref: 'common-types-v3.yaml#/components/parameters/fromTimestamp'
        - $ref: 'common-types-v3.yaml#/components/parameters/toTimestamp'
        - $ref: '#/components/parameters/interest'
        - $ref: '#/components/parameters/groupBy'
        - $ref: '#/components/parameters/includeTileDetails'
        - $ref: '#/components/parameters/limit'
        - $ref: '#/components/parameters/threshold'
        - $ref: '#/components/parameters/sortBy'
        - $ref: '#/components/parameters/eventTypesOnly'
        - $ref: '#/components/parameters/tileIdsOnly'
        - $ref: '#/components/parameters/tileTypesOnly'
        - $ref: '#/components/parameters/tileTypeIsNot'
        - $ref: '#/components/parameters/userAgentTypesOnly'
        - $ref: '#/components/parameters/tileGroupPathMatchingOnly'
        - $ref: '#/components/parameters/visitorTypesOnly'
        - $ref: '#/components/parameters/tileLanguagesOnly'
        - $ref: '#/components/parameters/primaryTagsOnly'
        - $ref: '#/components/parameters/secondaryTagsOnly'
        - $ref: '#/components/parameters/eventSourceTypesOnly'
        - $ref: '#/components/parameters/eventSourceNamesOnly'
        - $ref: '#/components/parameters/trafficSourceTypesOnly'
        - $ref: '#/components/parameters/trafficSourceNamesOnly'
        - $ref: '#/components/parameters/campaignsOnly'
        - $ref: '#/components/parameters/campaignMediumsOnly'
        - $ref: '#/components/parameters/campaignContentsOnly'

      security:
      - basicAuth: []

      responses:
        '200':
          description: "OK response"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TileEventCountersResponseClass'
        '404':
          description: "The given containerId does not exist"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '401':
          description: "Authentication failed - you provided invalid credentials or not provided credentials at all"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '403':
          description: "You have no permission to read statistics of the given Container"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'
        '400':
          description: "Something was wrong with the request"
          content:
            application/json:
              schema:
                $ref: 'common-types-v3.yaml#/components/schemas/BaseResponseClass'


  '/v1/system/clock':
    get:
      summary: "To query the system clock"
      tags:
      - System
      description: >
                Returns the system clock
                  
                Since you often phrase queries when you need to include timestamps it makes sense to be able to query the system clock
                which you can use to calculate potential diff in between your local (machine) clock and the server time. Considering this into
                queries might help a lot to significantly improve your server queries  
                  
                *note:* This endpoint is actually still coming from API v1 as you can see - we added it here for better visbility only.

      responses:
        '200':
          description: "OK response"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SystemClockResponseClass'


  '/v1/stat/counters/{containerId}/external-referrers':
  
    get:
      summary: "To query the external referrer distribution counters"
      tags:
      - Referrer counters
      description: >
                Returns the break down for external referrers  
                  
                *note:* This endpoint is actually still coming from API v1 as you can see - we added it here for better visbility only.  
                  
                **IMPORTANT!** You find details in our [query-api v1.0](/swagger-ui/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fkeytiles%2Fkeytiles-public-api%2Fmain%2Fsrc%2Fmain%2Fopenapi%2Fquery-api-v1.yaml#/Referrer%20counters/get_v1_stat_counters__containerId__external_referrers) contract!
      parameters:
        - $ref: 'common-types-v3.yaml#/components/parameters/containerId'
      responses: {}

        
components:

  securitySchemes:
    basicAuth:
      type: http
      scheme: basic
      description: "Basic HTTP authentication is used which means you need to send your Keytiles username/password in the header - API operations are handled on behalf of the given user. For more info visit: https://en.wikipedia.org/wiki/Basic_access_authentication"
      
  parameters:

    eventTypesOnly:
      name: eventTypesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of event types you want to limit the query for. If you list more values here then they are interpreted with an OR operator.
                      
                    note: if you have comma in your event names (strange, but ok...) you can escape that with `\\` character!  
      example: 'view,contact-form-sent'

    tileIdsOnly:
      name: tileIdsOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of tileIds you want to limit the query for - of course in this case only the counters of these tiles are returned. 
                    If you list more values here then they are interpreted with an OR operator. 
                      
                    note: if you have comma in your tileIds (strange, but ok...) you can escape that with `\\` character!  
      example: 'tile123,tile456,tile789'

    tileTypesOnly:
      name: tileTypesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of tile types you want to limit the query for. If you list more values here then they are interpreted with an OR operator.  
                      
                    IMPORTANT! You can not use this together with `tileTypeIsNot` parameter! You can only use this or that but not both.  
                      
                    In the list you can either use:
                     * The name of the type ('frontpage', 'page', 'article', ...), or
                     * The numeric ID of the tile type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**

      example: 'article,page'

    tileTypeIsNot:
      name: tileTypeIsNot
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of tile types you want the query to be excluded from. If you list more values here then they are interpreted with an OR operator.  
                      
                    IMPORTANT! You can not use this together with `tileTypesOnly` parameter! You can only use this or that but not both.  
                      
                    In the list you can either use:
                     * The name of the type ('frontpage', 'page', 'article', ...), or
                     * The numeric ID of the tile type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**

      example: 'article,page'


    tileGroupPathMatchingOnly:
      name: tileGroupPathMatchingOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of matchers (see below) which returns counters only for those Tiles who's tileGroupPath is matching to one of the listed matchers.
                    So if you list more values here then they are interpreted with an OR operator.  
                      
                    note: if you have comma in your matcher (strange, but ok...) you can escape that with `\\` character!  
                      
                    You can use the **'\*'** character to match any substring. But where and how you put this Asterisk character matters! Let us show
                    you how through an example!
                    
                    Let's assume you have articles and pages (Tiles) in the following content areas:  
                      
                     * /auto
                     * /tech
                     * /tech/mobile-rumours
                     * /tech/mobile
                     * /tech/mobile/android
                     * /tech/mobile/ios
                     * /politics
                      
                    And now you execute queries with two different **tileGroupPathMatchingOnly** settings:
                     1. **"/tech/mobile\*"** and
                     1. **"/tech/mobile/\*"**
                    
                    In the first query **"/tech/mobile\*"** would match for everything begins with "/tech/mobile" string. So this would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* Tiles but
                    also would include *"/tech/mobile-rumours"* Tiles. Which are clearly two different areas right?  
                      
                    But what if you want to really limit for Tiles under the *"/tech/mobile"* area?  
                      
                    Well then you can use the second query value: **"/tech/mobile/\*"**. This would include *"/tech/mobile/android"*, *"/tech/mobile/ios"* but
                    would NOT include *"/tech/mobile-rumours"* anymore - as that is not a match anymore. But we are not done yet! Please note: this
                    would also include Tiles under *"/tech/mobile/"* group itself. Because **"/\*"** means "everything which is under this group"
                     
      example: '/tech/mobile/*, */errors/*'

    userAgentTypesOnly:
      name: userAgentTypesOnly
      in: query
      required: false
      schema:
        type: string
      example: 'browser-desktop,NULL'
      description: >
                    Data filter option. Comma separated list of *userAgentType*s you want to limit the query for. If you list more values here then they are interpreted with an OR operator.
                      
                    In the list you can either use:
                     * The name of the UserAgent type (see below), or
                     * The numeric ID of the UserAgent type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                      
                    note: if you have comma in your userAgent types (strange, but ok...) you can escape that with `\\` character!  
                      
                    The built-in values are the following:
                     * **browser-desktop** - visitor is using a standard web browser running on a desktop computer
                     * **browser-mobile** - visitor is using a standard web browser running on a mobile device
                     * **bot** - visitor was a known bot
                     * **unknown** - if during hit-collection (see Hit Collection API!) *userAgentType* was not given or was NULL
                    then Keytiles system will fall back to this value  
                      
                    tip: see [/v2/stat/webhits/{containerId}/idmappings](#/WebHits%20-%20Event%20counters/get_v2_stat_webhits__containerId__eventcounts) endpoint docs! With that you can query which userAgentTypes Keytiles have seen. 

    visitorTypesOnly:
      name: visitorTypesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of *visitorType*s you want to limit the query for. If you list more values here then they are interpreted with an OR operator.
                      
                    In the list you can either use:
                     * The name of the visitor type, or
                     * The numeric ID of the visitor type - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                      
                    note: if you have comma in your visitor types (strange, but ok...) you can escape that with `\\` character!  
                      
                    **NULL** is a special value indicating cases where *visitorType* was not set.
                      
                    Please note that visitorTypes is something you introduce for your Container tracking! If you do not do this then all your
                    traffic falls under "NULL" value here.
      example: 'paid,NULL'

    tileLanguagesOnly:
      name: tileLanguagesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of ISO-639-2 languages codes (e.g. 'en', 'de', ...). Only data captured on the given languages is returned if you
                    apply this filter. If you list more values here then they are interpreted with an OR operator.  
                      
                    **NULL** is a special value indicating cases where *tileLanguage* was not identified/captured.
      example: 'en,de'

    eventSourceTypesOnly:
      name: eventSourceTypesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of "link", "search", "social", "direct" or "internal" strings - indicating from which source
                    the events came. If you list more values here then they are interpreted with an OR operator so sending in e.g. "link, search" would return everything which
                    came from "link" or "search".
      example: 'link,direct'


    tagValuesOnly:
      name: tagValuesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of "link", "search", "social", "direct" or "internal" strings - indicating from which source
                    the events came. If you list more values here then they are interpreted with an OR operator so sending in e.g. "link, search" would return everything which
                    came from "link" or "search".
      example: 'link,direct'


    eventSourceNamesOnly:
      name: eventSourceNamesOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of external source names - indicating from which exact source
                    the events came. If you list more values here then they are interpreted with an OR operator.  
                      
                    In the list you can either use:
                     * The name of the external source, or
                     * The numeric ID of the external source - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                      
                    Note: the names you specify here are definitely correlating with source type (we mentioned in 'eventSourceTypesOnly' description) "link", "search", "social", "direct" or "internal"!

                    The correlation looks like this:
                     * "link": then the name is basically the hostname of the website which sent the visitor to your website. Like "abc.com".
                     * "social": then the name is the name how Keytiles classified it for Social sources - here please take a look at [How does referrer grouping work?](https://www.keytiles.com/docs/how-does-referrer-grouping-work#The-referrer-classifying-configuration)
                     * "search": then the name is the name how Keytiles classified it for Search sources - here please take a look at [How does referrer grouping work?](https://www.keytiles.com/docs/how-does-referrer-grouping-work#The-referrer-classifying-configuration)
                     * "direct" or "internal": they do not have a name, name is always NULL for these

                    So be careful when you are using this filter how you set up `eventSourceTypesOnly` if you use it!

                    For example:
                     * If you are curious about events came from "Facebook" then you can send `eventSourceNamesOnly=Facebook`. (note: this belongs to source type "social" - see 'eventSourceTypesOnly')
                     * If you are curious about events came from another website "abc.com" which is an external link then you can send `eventSourceNamesOnly=abc.com`. (note: this belongs to source type "link" - see 'eventSourceTypesOnly')
                     * If you send `eventSourceNamesOnly=Facebook,abc.com` that would give you all events came from "Facebook" OR "abc.com". (note: and then this would belong to source types "link" and "social" - see 'eventSourceTypesOnly')
                     * If you would send `eventSourceNamesOnly=abc.com & eventSourceTypesOnly=direct` you would receive 0 as a result - because for sure nothing comes in from "abc.com" which events came from a "direct" visit ...
                      
      example: 'facebook,abc.com'

    trafficSourceNamesOnly:
      name: trafficSourceNamesOnly
      in: query
      required: false
      deprecated: true
      schema:
        type: string
      description: >
                    This is **deprecated!** Please use `eventSourceNamesOnly` or `visitSourceNamesOnly` instead to specify your interest precisely!

                    If you do use this option then to maintain backward compatibility this is an alias for `eventSourceNamesOnly`.
      example: 'facebook,google.de'


    trafficSourceTypesOnly:
      name: trafficSourceTypesOnly
      in: query
      deprecated: true
      required: false
      schema:
        type: string
      description: >
                    This is **deprecated!** Please use `eventSourceTypesOnly` or `visitSourceTypesOnly` instead to specify your interest precisely!

                    If you do use this option then to maintain backward compatibility this is an alias for `eventSourceTypesOnly`.
      example: 'link,direct'



    campaignsOnly:
      name: campaignsOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option.  
                      
                    Either
                     * Comma separated list of campaigns - indicating from which campaigns the visitor arrived to your website. If you list more values here then they are interpreted with an OR operator.  
                     * A simple `*` value which tells Keytiles to return counters belong to *any* Campaign regardless which one it is.  
                      
                    In the comma separated list you can either use:
                     * The name of the Campaign, or
                     * The numeric ID of the Campaign - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                      
                    Campaign tracking in Keytiles works based on Urchin Tracking Module (UTM) parameters specification. For more info visit: [Wikipedia - UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters)  
    campaignMediumsOnly:
      name: campaignMediumsOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of campaign mediums - indicating from which campaign mediums
                    the visitor arrived to your website.  
                      
                    In the list you can either use:
                     * The name of the Campaign Medium, or
                     * The numeric ID of the Campaign Medium - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                      
                    Campaign tracking in Keytiles works based on Urchin Tracking Module (UTM) parameters specification. For more info visit: [Wikipedia - UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters)

    campaignContentsOnly:
      name: campaignContentsOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of campaign contents - indicating from which campaign contents
                    the visitor arrived to your website.  
                      
                    In the list you can either use:
                     * The name of the Campaign Content, or
                     * The numeric ID of the Campaign Content - returned by `/v2/stat/webhits/{containerId}/idmappings` endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**
                      
                    Campaign tracking in Keytiles works based on Urchin Tracking Module (UTM) parameters specification. For more info visit: [Wikipedia - UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters)

    primaryTagsOnly:
      name: primaryTagsOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of matching primary custom tags.  
                      
                    This is the pair of `primaryTags` in our [Hit Collection API](https://www.keytiles.com/developer-area/keytiles-apis#hit-collection-api).
                    If you use them to segment your traffic your custom way then now you can filter for them with this prameter.  
                      
                    To understand it better what these "tags" are doing and how you can use it for your own goals please check our article:
                    [Custom segmentation of traffic](https://keytiles.com/developer-area/custom-segmentation-of-traffic)!  
                      
                    **Good to know!** If you are curious about traffic where there was no primary cutom tag at all you have a special option here! You can encode the "no tags at all" by adding "id:0"
                    to this param so `primaryTagsOnly=id:0` encodes exactly this.
    secondaryTagsOnly:
      name: secondaryTagsOnly
      in: query
      required: false
      schema:
        type: string
      description: >
                    Data filter option. Comma separated list of matching secondary custom tags.  

                    It works the same way as `primaryTagsOnly` - please read info there!

    interest:
      name: interest
      in: query
      required: false
      schema:
        type: string
      description: >
                    Comma separated list of your extra interest.  
                      
                    It is "extra interest" because by default only the `eventCountTotal` counter is returned. But with extending
                    your interest you can get more counters.  
                      
                    The possible values are the following:
                     * **newVisitors**  
                       You will get the `eventCountUnknownNewVsRetVisitor` and `eventCountNewVisitor` counters additionally. You can compute the number of
                       "returning" visitors with the formula `eventCountTotal - eventCountUnknownNewVsRetVisitor - eventCountNewVisitor`.  
                     * **bounceVisitors**  
                       You will get the `eventCountNoSession` and `eventCountBounceVisitor` counters additionally. You can compute the number of "non-bounce" visitors
                       with the formula `eventCountTotal - eventCountNoSession - eventCountBounceVisitor`.
                     * **newVisitors,bounceVisitors**  
                       If you request both together then you do not simply get union of counters but actually a few more too. You would get `eventCountNoSession`, `eventCountUnknownNewVsRetVisitor`, 
                       `eventCountNewVisitor`, `eventCountBounceVisitor`, `eventCountBounceNewVisitor` and `eventCountBounceUnknownNewVsRetVisitor`.  
                       We *really recommend* to check and read our article (see below) explaining things!
                     * **referrerCounts**  
                       You will get the `eventCountDirect`, `eventCountSearchReferrer`, `eventCountSocialReferrer`, `eventCountLinkReferrer` 
                       and `eventCountCampaignReferrer` counters additionally. If you are curious about how many internal (visitor is visiting a certain article coming
                       from another page on your website already) click happened you can compute this with formula `eventCountTotal - eventCountDirect - eventCountSearchReferrer - eventCountSocialReferrer - eventCountLinkReferrer` easily. 
                     * **visitSession**  
                       You will get the `eventCountNoSession`, `visitSessionStartedCount` and `visitSessionEventFirstOfTypeCount` counters additionally.
                       
                     You can find more information about the available event counters in our website Developer Area here: 
                     [Returned event counters and their meaning](https://www.keytiles.com/developer-area/query-api-v2/webhits-event-counter-queries#event-counters-reference)
                    
      example: 'newVisitors,bounceVisitors'

    includeTileDetails:
      name: includeTileDetails
      in: query
      required: false
      schema:
        type: string
      description: >
                    This is a boolean parameter so you can send `true` or `false` here as a value. By default the value is `true`.  
                      
                    When you query the tile counters apart from the counters in the response Keytiles also returns information about the tiles
                    like `firstSeen`, `lastSeen` (see: *TileClass*) and `titles` and `urls` (see: *TileGroupPathClass*). The fact is that due to
                    server side storage logic returning this information happens in an extra step making the query more expensive and slower.  
                      
                    However there are scenarios when you do not really need this data (you might know these from an earlier query) so to speed
                    up the query you can tell Keytiles to save this effort.   
                    
      example: 'false'
 
    groupBy:
      name: groupBy
      in: query
      required: false
      schema:
        type: string
      description: >
                    Comma separated list of criteria you want to have the data grouped by.  
                      
                    Normally without using this option you just get the requested counters (fine grained by *interest* parameter) aggregated into sum
                    values in the query range. This will tell you "your site received 1242 events in this time range" without any further break down.
                    However if you for example want to see "ok but how many different events did I get" you need a way to tell this wish to Keytiles.  
                      
                    In this case you could send in `groupBy=eventType` and as a result in the response instead of the one 1242 (sum) number you will see
                    this came together from view 846, download 129 and contact-form-sent 267 times. So you get a break down by `eventType` in this
                    case. This is useful if your goal is to show on a bar chart for example the different event types ratio.  
                      
                    And if you want to get this data in an - let's say - hourly resolution then you can go further and send in `groupBy=eventType,time:1h`
                    in this parameter.  
                      
                    There are more criteria not just `eventType` or `time` and you can combine them.  
                      
                    **But BE AWARE!** More criteria you request makes the response bigger and bigger as the returned counters are broke down into more and more groups so you have to keep an eye on what you really need!  
                       
                    The possible values are the following:
                     * **time:x<m|h|d|w>** - you can specify a time window like `2h` which means 2 hours groups (`m`=minutes, `h`=hours, `d`=days, `w`=weeks) with this - you get the counters aggregated per time window in the response
                     * **eventType** - you get the counters aggregated per event types in the response  
                     See also: `eventTypesOnly` filter option!
                     * **userAgentType** - you get the counters aggregated per userAgent types in the response  
                     See also: `userAgentTypesOnly` filter option!
                     * **visitorType** - you get the counters aggregated per visitor types in the response  
                     See also: `visitorTypesOnly` filter option!
                     * **tileType** - you get the counters aggregated per tileTypes in the response  
                     See also: `tileTypesOnly` filter option!
                     * **tileGroupPath** - you get the counters aggregated per tileGroupPaths in the response  
                     See also: `tileGroupPathsOnly` filter option!
                     * **tileLanguage** - you get the counters aggregated per languages in the response  
                     See also: `tileLanguagesOnly` filter option!
                     * **primaryTags[:max]** - you get the counters aggregated per primary (custom) tags in the response  
                     but since there could be a lot you can optionally specify let's say "max top 10" in which case you get your top 10 plus all `other` as one group.  
                     See also: `primaryTagsOnly` filter option for more details!
                     * **secondaryTags[:max]** - you get the counters aggregated per secondary (custom) tags in the response  
                     but since there could be a lot you can optionally specify let's say "max top 10" in which case you get your top 10 plus all `other` as one group.  
                     See also: `secondaryTagsOnly` filter option for more details!
                     * **eventSourceType** - you get the counters aggregated per event source types in the response like `search`, `social`, etc.  
                     See also: `eventSourceTypesOnly` filter option!
                     * **eventSourceName[:max]** - you get the counters aggregated per event sources in the response like `Facebook`, etc
                                                     but since there could be a lot you can optionally specify "max top 10" in which case you get your
                                                     top 10 plus all `other` as one group  
                     See also: `eventSourceNamesOnly` filter option!
                     * **visitSourceType** - you get the counters aggregated per types of source of the visit in the response like `search`, `social`, etc.  
                     See also: `visitSourceTypesOnly` filter option!
                     * **visitSourceName[:max]** - you get the counters aggregated per names of source of the visit in the response like `Facebook`, etc
                                                     but since there could be a lot you can optionally specify "max top 10" in which case you get your
                                                     top 10 plus all `other` as one group  
                     See also: `visitSourceNamesOnly` filter option!
                     * **campaign[:max]** - you get the counters aggregated per campaigns in the response  
                                            but since there could be a lot you can optionally specify "max top 10" in which case you get your
                                            top 10 plus all `other` as one group  
                     See also: `campaignsOnly` filter option!
                     * **campaignMedium[:max]** - you get the counters aggregated per campaign mediums in the response  
                                            but since there could be a lot you can optionally specify "max top 10" in which case you get your
                                            top 10 plus all `other` as one group  
                     See also: `campaignMediumsOnly` filter option!
                     * **campaignContent[:max]** - you get the counters aggregated per campaign contents in the response  
                                            but since there could be a lot you can optionally specify "max top 10" in which case you get your
                                            top 10 plus all `other` as one group  
                     See also: `campaignContentsOnly` filter option!
                     * **trafficSourceType** - **deprecated!** Please use `eventSourceType` or `visitSourceType` instead!
                     * **trafficSourceName[:max]** - **deprecated!** Please use `eventSourceName` or `visitSourceName` instead!

      example: 'eventType,time:1h'
  
    limit:
      name: limit
      in: query
      required: false
      schema:
        type: integer
      description: >
                    Maximum number of tiles in the response. By saying `limit=100` you will get back the top 100 tiles only who received the
                    most event counts alltogether during the query range.   
  
    threshold:
      name: threshold
      in: query
      required: false
      schema:
        type: string
      description: >
                    In this parameter you can setup a threshold either with absolute value or with percentage.  
                      
                    If you use
                     * absolute value, like `threshold=10` then you will get back only those tiles and their details who received at least 10 hits
                       during the query range
                     * percentage value, like `threshold=3.5%` then you will get back only those tiles and their details who received at least 3.5% of the
                       hits got by the tile which received the most hits during the query range                      

    sortBy:
      name: sortBy
      in: query
      required: false
      schema:
        type: string
      description: >
                    When you use `limit` or `threshold` parameters you can optionally define which Counter column should be used to order the
                    records so term like 'top 100 Tiles' becomes well defined. Sorts the tiles in desc order based on the returned event counter field you specify here.  
                      
                    **note:** This parameter is only used if you use `?limit=` or `?threshold=` parameters! Otherwise query will fail. Reason: server
                    will not sort the tiles anyhow without reason as this is extra effort to do it on server side.  
                      
                    You can use any event counter (see `?interest` parameter!) which is in the response for this.  
                      
                    By default the `eventCountTotal` field is used - if you omit this parameter. But maybe you actually want something different...
                    Maybe you want to sort the 'top 100' tiles based on `visitSessionStartedCount` because you are curious about the top landing
                    pages?  
                      
                    In some cases you also have extra options here which are the following:
                     * `eventCountTotal[:eventType1,eventType2,...,eventTypeN]`  
                       If you use `eventCountTotal` then you also have the possibility to provide a comma separated list of event types. If you do then                     
                       only the SUM of those event types are used to form up the `eventCountTotal` and participate in the sorting.  
                         
                       Some notes to consider:
                         * This possibility can be only used together with using `?groupBy=eventType` - otherwise your query will fail
                         * If you also use `?eventTypesOnly` filter then you can only use those event types which are part of the filter too - otherwise your
                         query will fail.
                         * In the event type list instead of name of the event type you can also use its numeric ID - returned by `/v2/stat/webhits/{containerId}/idmappings`
                         endpoint - using the format `id:<numeric ID>`, e.g. **"id:123"**. So alltogether you send in something looks like this: `eventCountTotal:id:123,id:456`
                      
    mappingTypes:
      name: mappingTypes
      in: query
      required: true
      schema:
        type: string
      description: >
                    Comma separated list - at least one element - of the following:
                     * eventType
                     * userAgentType
                     * visitorType
                     * tileType
                     * tileGroupPath
                     * referrerName
                     * campaign
                     * campaignMedium
                     * campaignContent
                     * primaryTag
                     * secondaryTag
                    
    includeFirstLastSeenTs:
      name: includeFirstLastSeenTs
      in: query
      required: false
      schema:
        type: string
      description: >
                    This is a boolean parameter so you can send `true` or `false` here as a value. By default the value is `false`.  
                      
                    This controls whether to add first/last seen timetamps to each record or not. In most of the cases this is irrelevant
                    so to save response size by default we do not do this
      example: 'false'
  
  schemas:
  
    # This enum defines error/warning codes belong to Stat API endpoints specifically
    # note: no support in OpenApi for now how to document values so we just add the description as comments for now.
    #       see: https://github.com/OAI/OpenAPI-Specification/issues/348 
    StatApiEndpointLocalErrorCodes:
      type: string
      enum:
      # You requested data from a specific timestamp in the query range but the 'from' timestamp was extended.
      # This comes with a warning level message only. It happens when Keytiles data granularity does not allow to serve data from timestamp you specified in the query range but must be aligned (pull it earlier)
      # See ContainerQueryRangeResponseClass.requestedFromTimestamp and ContainerQueryRangeResponseClass.dataFromTimestamp!
      - queryRange_from_extended
      # You requested data until (to) a specific timestamp in the query range but the 'to' timestamp was extended.
      # This comes with a warning level message only. It happens when Keytiles data granularity does not allow to serve data until the specified timestamp in the query range but must be aligned (pushed it later)
      # See ContainerQueryRangeResponseClass.requestedToTimestamp and ContainerQueryRangeResponseClass.dataToTimestamp!
      - queryRange_to_extended
      - queryRange_extended
      - queryRange_corrected
      - queryRange_from_corrected
      - queryRange_to_corrected
      # The ID of the container was not provided - it is missing
      - containerId_missing
      # The ID of the Container is not valid - there is no Container with this ID
      - containerId_invalid
      - containerSetup_invalid
      # This happens on 400 "Bad request" if user sends in *Only filter parameter however this filter can not be supported
      # by that query endpoint. In this case user must remove that filter which is named
      - filter_not_supported
      # If 'sortBy' is pointing to a column which is not available due to 'interest' parameter this error is raised
      - sorting_column_not_in_interest
      # If 'sortBy=eventCountTotal:evenType1,eventType2,...' then we need to have 'groupBy=eventType' param at least
      - groupBy_eventType_not_set 
      

    # Let's merge the "local" error codes with the "global" ones in this enum
    # Stat API endpoints can return the union of them 
    StatApiEndpointErrorCodes:
      description: NOTE! Error codes is an Enum. Unfortunately in OpenApi (so far) there is no possibility to provide description for Enum values. But we have detailed description of each error codes! Please check the OpenApi file in our Github repo - you find them as comments for each Enum values! 
      allOf:
      - $ref: "#/components/schemas/StatApiEndpointLocalErrorCodes"
      - $ref: "common-types-v3.yaml#/components/schemas/CommonErrorCodes"

  
    EventCountersResponseClass:
      allOf:
        - $ref: 'common-types-v3.yaml#/components/schemas/ContainerQueryRangeResponseClass'    
        - type: object
          properties:
            keyColumnsMappings:
              $ref: '#/components/schemas/KeyColumnsIntIdMappingsClass'
            resultColumns:
                $ref: '#/components/schemas/EventCountersHeaderClass'
            aggregatedCounterRows:
              type: array
              description: >
                            These are the rows of the data - each row represented by an array of Integer values.  
                              
                            In rows the number of columns and the index of each colum is identical to the description you find in `/resultColumns` entry!
              items:
                type: array
                items:
                  type: integer
                  format: int64
  
    TileEventCountersResponseClass:
      allOf:
        - $ref: '#/components/schemas/EventCountersResponseClass'    
        - type: object
          properties:
            tiles:
              type: object
              description: Containes Tile counters and Tile details. This is a map. Keys are tileIds.
              additionalProperties:
                $ref: '#/components/schemas/TileClass'


    GetTilesResponseClass:
      allOf:
        - $ref: 'common-types-v3.yaml#/components/schemas/ContainerResponseClass'    
        - type: object
          properties:
            tiles:
              type: object
              description: Containes Tile details. This is a map. Keys are tileIds.
              additionalProperties:
                $ref: '#/components/schemas/TileDataClass'


    TileDataClass:
      type: object
      properties:
        typeName:
          type: string
          description: > 
                        Gives you the type of the tile.
        labelsJSON:
          type: string
          nullable: true
          description: >
                        You can store some labels - key-value pairs - for Tiles. They are collected during hit collection (see: Hit Collection API - [https://www.keytiles.com/developer-area/hit-attributes](https://www.keytiles.com/developer-area/hit-attributes#tileLabelsJSON)).  
                          
                        If you do so you get back the JSON string representation of these labels in this field - or you get NULL if there are no labels stored.
        firstSeen:
          type: integer
          format: int32
          nullable: true
          description: >
                        When did we register the first event for this tile? Basically: publish time of this tile. UNIX timestamp (seconds since Epoch) in UTC.  
                          
                        note: this info you just get if you have NOT executed the request with `?includeTileDetails=false`!
          example: 1543355708
        lastSeen:
          type: integer
          format: int32
          nullable: true
          description: >
                        When did we register the last event for this tile? UNIX timestamp (seconds since Epoch) in UTC.  
                          
                        note: this info you just get if you have NOT executed the request with `?includeTileDetails=false`!
          example: 1543355708
        tileGroupPaths:
          type: object
          nullable: true
          description: >
                        Contains information about under which tileGroupPaths this Tile showed up in the query range. This is a map. Keys are IDs assigned to tileGroupPath - you can resolve them with entried in `/keyColumnsMappings/tileGroupPath` 
                          
                        note: this info you just get if you have NOT executed the request with `?includeTileDetails=false`!
          additionalProperties:
            $ref: '#/components/schemas/TileGroupPathClass'


    TileClass:
      type: object
      properties:
#        id:
#          type: string
#          description: "ID of the tile"
        type:
          type: integer
          format: int32
          description: > 
                        Gives you the type of the tile. The integer is the ID of the tile type which you can get back from `/keyColumnsMappings/tileType` part  
                          
                        note: this value is always present
        # typeName:
        #   type: string
        #   description: > 
        #                 Gives you the type of the tile as a string. The resolved 'type' ID basically.
        labelsJSON:
          type: string
          nullable: true
          description: >
                        You can store some labels - key-value pairs - for Tiles. They are collected during hit collection (see: Hit Collection API - [https://www.keytiles.com/developer-area/hit-attributes](https://www.keytiles.com/developer-area/hit-attributes#tileLabelsJSON)).  
                          
                        If you do so you get back the JSON string representation of these labels in this field - or you get NULL if there are no labels stored.
        firstSeen:
          type: integer
          format: int32
          nullable: true
          description: >
                        When did we register the first event for this tile? Basically: publish time of this tile. UNIX timestamp (seconds since Epoch) in UTC.  
                          
                        note: this info you just get if you have NOT executed the request with `?includeTileDetails=false`!
          example: 1543355708
        lastSeen:
          type: integer
          format: int32
          nullable: true
          description: >
                        When did we register the last event for this tile? UNIX timestamp (seconds since Epoch) in UTC.  
                          
                        note: this info you just get if you have NOT executed the request with `?includeTileDetails=false`!
          example: 1543355708
        tileGroupPaths:
          type: object
          nullable: true
          description: >
                        Contains information about under which tileGroupPaths this Tile showed up in the query range. This is a map. Keys are IDs assigned to tileGroupPath - you can resolve them with entried in `/keyColumnsMappings/tileGroupPath` 
                          
                        note: this info you just get if you have NOT executed the request with `?includeTileDetails=false`!
          additionalProperties:
            $ref: '#/components/schemas/TileGroupPathClass'
        counterRows:
          type: array
          items:
            type: array
            items:
              type: integer
              format: int64
          
    TileGroupPathClass:
      type: object
      properties:
        urls:
          type: array
          description: 'The list of (cleaned, means: removed query arguments, anchors) URLs we captured for this tile under this tileGroupPath'
          items:
            type: string
            example: "https://mywebsite.com/politics/ausland"
        titles:
          type: array
          description: 'The list of titles we captured for this tile under this tileGroupPath. Please note: normally this should just be one title! If you see more than it is against our recommended best practices and you should take actions!'
          items:
            type: string
            example: "My tile title"


    TimeIntervalClass:
      type: object
      properties:
        starts:
          type: integer
          format: int32
          description: 'Beginning of interval in seconds relative to the returned global data time-frame. If you want to know absolute timestamp then add this to `/dataFromTimestamp` attribute value'
          example: 0
        length:
          type: integer
          format: int32
          description: 'Length of this interval in seconds'
          example: 100

    IntIdToStrMappingClass:
      nullable: true
      type: object
      description: >
                    To save lots of space Keytiles maps Strings to unique Integers (acting as IDs) - this way can return counter rows 
                    as just Integer arrays. Of course to make it readable again you need the reverse mapping: which Integer encodes which Strings?
                    This is this mapping.  
      additionalProperties:
        type: string
        example: '<the name>'

    TimeColumnIntIdToIntervalMappingClass:
      type: object
      nullable: true
      x-keytiles-serialize-only-if-non-default-properties:
      - time
      properties:
        time:
          description: This entry is present only if you requested `groupBy=time:x` - so break down by time intervals - in your request. The keys in this object are numerical IDs of time intervals while values giving you attributes of each intervals.
          type: object
          nullable: true
          additionalProperties:
            $ref: '#/components/schemas/TimeIntervalClass'


    KeyColumnsIntIdMappingsClass:
      description: >
                    This object gives you concrete values for "groupBy" criteria if you requested data groups using the `groupBy` parameter. 
      nullable: true
      allOf:
      - $ref: '#/components/schemas/TimeColumnIntIdToIntervalMappingClass'    
      - type: object
        nullable: true
        x-keytiles-serialize-only-if-non-default-properties:
        - eventType
        - visitorType
        - userAgentType
        - tileLanguage
        - tileType
        - tileGroupPath
        - eventSourceType
        - eventSourceName
        - visitSourceType
        - visitSourceName
        - trafficSourceType
        - trafficSourceName
        - campaign
        - campaignMedium
        - campaignContent
        - primaryTags
        - secondaryTags
        properties:
          eventType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          visitorType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          userAgentType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          tileLanguage:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          tileType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          tileGroupPath:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          eventSourceType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          eventSourceName:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          visitSourceType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          visitSourceName:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          trafficSourceType:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          trafficSourceName:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          campaign:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          campaignMedium:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          campaignContent:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          primaryTags:
            $ref: '#/components/schemas/IntIdToStrMappingClass'
          secondaryTags:
            $ref: '#/components/schemas/IntIdToStrMappingClass'

    EventCountersHeaderClass:
      type: object
      description: >
                    You will get data as an array of Integer values - like in a .csv file. This object gives you the name of the columns. So the `headers` so to speak.  
                      
                    In the data rows (int array) you will always have `keyColumns` + `counterColumns` number of integers and you need to interpret them in this order.  
                      
                    Possible counter columns are the following:
                    
      properties:
        keyColumns:
          type: array
          items:
            type: string
          example: ['time', 'eventType']
          nullable: false
          description: >
                        This array tells you the names of key columns - in an index maintained form. This just has values if you request `groupBy` setup.  
                          
                        Possible key columns are the following:
                         * time
                         * eventType
                         * userAgentType
                         * visitorType
                         * tileType
                         * tileGroupPath
                         * tileLanguage
                         * trafficSourceType (deprecated, `eventSourceType` and `visitSourceType` took over)
                         * trafficSourceName (deprecated, `eventSourceName` and `visitSourceName` took over)
                         * eventSourceType
                         * eventSourceName
                         * visitSourceType
                         * visitSourceName
        counterColumns:
          type: array
          items:
            type: string
          example: ['eventCountTotal', 'eventCountNoSession', 'eventCountNewVisitor', 'eventCountBounceVisitor', 'eventCountBounceNewVisitor', 'eventCountBounceUnknownNewVsRetVisitor']
          nullable: false
          description: >
                        This array tells you the names of counter columns - in an index maintained form.
                        But please keep in mind: these are always placed after the `keyColumns`!    
                          
                        Please note: what you get here depends on what you request using the `?interest=` parameter. See 'interest' parameter description for more details!

    MappingRecordClass:
      type: object
      x-keytiles-serialize-only-if-non-default-properties:
      - firstSeenTs
      - lastSeenTs
      properties:
        strId:
          type: string
          nullable: false
        intId:
          type: integer
          nullable: false
        firstSeenTs:
          type: integer
          nullable: true
        lastSeenTs:
          type: integer
          nullable: true
    
    GetIdMappingsResponseClass:
      allOf:
        - $ref: 'common-types-v3.yaml#/components/schemas/ContainerQueryRangeResponseClass'    
        - type: object
          x-keytiles-serialize-only-if-non-default-properties:
          - eventTypes
          - visitorTypes
          - userAgentTypes
          - tileLanguages
          - tileTypes
          - tileGroupPaths
          - trafficSourceNames
          - campaigns
          - campaignMediums
          - campaignContents
          - primaryTags
          - secondaryTags
          properties:
            eventTypes:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            visitorTypes:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            userAgentTypes:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            tileLanguages:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            tileTypes:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            tileGroupPaths:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            trafficSourceNames:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            campaigns:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            campaignMediums:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            campaignContents:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            primaryTags:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'
            secondaryTags:
              type: array
              nullable: true
              items:
                $ref: '#/components/schemas/MappingRecordClass'



    SystemClockResponseClass:
      type: object
      properties:
        serverTime:
          type: integer
          format: int32
          description: "Current server time in UNIX timestamp in UTC (seconds since Epoch) when this response was generated"
          example: 1543355710


    